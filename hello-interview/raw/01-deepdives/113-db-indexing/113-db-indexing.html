<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <script src='main.js'></script>
</head>
<body>
    <div id="markdown" class="mui-46nw7a"><div><div class="flex flex-col gap-2 md:gap-4"><div class="flex flex-col"><h6 class="MuiTypography-root MuiTypography-h6 mui-zfm63x">Deep Dives</h6><h1 class="MuiTypography-root MuiTypography-h2 mui-161snwm">Database Indexing</h1><p class="MuiTypography-root MuiTypography-body2 mui-45a2r">Learn about how database indexing works and how to optimize your queries</p></div></div><hr class="MuiDivider-root MuiDivider-fullWidth mui-1rvhejo"></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="intro">Intro</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Database performance can make or break modern applications. Think about what is takes to search for a user's profile by email in a table with millions of records. Without any optimizations, the database would have to check each row sequentially, scanning through every single record until it finds a match. For a table with millions of rows, this becomes painfully slow - like searching through every book in a library one by one to find a specific novel.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is where indexes come in handy. By maintaining separate data structures optimized for searching, indexes allow databases to quickly locate the exact records we need without examining every row. From finding products in an e-commerce catalog to loading user profiles in a social network, indexes are what make fast lookups possible.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Knowing when to add an index, to what columns, and what type of index is a critical part of system design. Choosing the right indexes is often a key focus in interviews. For mid-level engineers, understanding basic indexing strategies is expected. For staff-level engineers, mastery of different index types and their trade-offs is essential.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In this deep dive, we'll explore how database indexes work under the hood and the different types you'll encounter. We'll start with the core concepts of how indexes are stored and accessed, then examine specific index types like B-trees, hash indexes, geospatial indexes, and more. For each type, we'll cover their strengths, limitations, and when to use them in your system design interviews.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's begin by understanding exactly how databases store and use indexes to make our queries efficient.</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Indexing and data organization tends to be a stronger focus in infrastructure style interviews. For full-stack and product-focused roles, you'll likely only need a basic understanding of when and why to use indexes. The depth we cover here goes beyond what's typically asked in full-stack interviews, but understanding the fundamentals will help you make better decisions when designing and optimizing your applications.</div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="how-database-indexes-work">How Database Indexes Work</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we store data in a database, it's ultimately written to disk as a collection of files. The main table data is typically stored as a heap file - essentially a collection of rows in no particular order. Think of this like a notebook where you write entries as they come, one after another.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="physical-storage-and-access-patterns">Physical Storage and Access Patterns</h3>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Unless interviewing for a database internals role, the details here are not going to be asked in an interview. That said, they are an important foundation to understand the problem of why we need indexes.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Modern databases face an interesting challenge: they need to store and quickly access vast amounts of data. While the data lives on disk (typically SSDs nowadays), we can only process it when it's in memory. This means every query requires loading data from disk into RAM.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When querying without an index, we need to scan through every page of data one by one, loading each into memory to check if it contains what we're looking for. With millions of pages, this means millions of (relatively)slow disk reads just to find a single record. It's like having to flip through every page of a massive book to find one specific word.</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Modern databases have optimizations like prefetching and caching to make random access faster, but the point here still stands. It's too slow to scan through every page of data sequentially.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But with indexes, we transform our access patterns. Instead of reading through every page of data sequentially, indexes provide a structured path to follow directly to the data we need. They help us minimize the number of pages we need to read from storage by telling us exactly which pages contain our target data. It's the difference between checking every page in a book versus using the table of contents to jump straight to the relevant pages.</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While SSDs are the norm today, it's important to note that random access is still significantly slower than sequential access, even on SSDs. This is a common misconception - while the performance gap is smaller than with HDDs, it's still very real. And for systems still using HDDs, especially for large datasets, this performance difference becomes even more pronounced, making proper indexing absolutely critical.</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="the-cost-of-indexing">The Cost of Indexing</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But indexes aren't free - they come with their own set of trade-offs. Every index we create requires additional disk space, sometimes nearly as much as the original data.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Write performance takes a hit too. When we insert a new row or update an existing one, the database must update not just the main table, but every index on it. With multiple indexes, a single write operation can trigger several disk writes.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So when might indexes actually hurt more than help? The classic case is a table with frequent writes but infrequent reads. Think of a logging table where we're constantly inserting new records but rarely querying old ones. Here, the overhead of maintaining indexes might not justify their benefit. Similarly, for small tables with just a few hundred rows, the cost of maintaining an index and traversing its structure might exceed the cost of a simple sequential scan.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In reality, the impact of indexes on memory is often overblown. Modern databases have sophisticated buffer pool management that minimizes the performance hit of having multiple indexes. However, it's still a good idea to closely monitor index usage and avoid creating unnecessary indexes that don't provide significant benefits.</div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="types-of-indexes">Types of indexes</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There are lots of indexes, many of which fall into the tail and are rarely used but for specialized use cases. Rather than enumerating every type of index you may see in the wild, we're going to focus in on the most common ones that show up in system design interviews.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="b-tree-indexes">B-Tree Indexes</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">B-tree indexes are the most common type of database index, providing an efficient way to organize data for fast searches and updates. They achieve this by maintaining a balanced tree structure that minimizes the number of disk reads needed to find any piece of data.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="the-structure-of-b-trees">The Structure of B-trees</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A B-tree is a self-balancing tree that maintains sorted data and allows for efficient insertions, deletions, and searches. Unlike binary trees where each node has at most two children, B-tree nodes can have multiple children - typically hundreds in practice. Each node contains an ordered array of keys and pointers, structured to minimize disk reads.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/89dbb1659807ca310b05c3f33bfc61c0.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">b-tree</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Every node in a B-tree follows strict rules:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All leaf nodes must be at the same depth</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Each node can contain between m/2 and m keys (where m is the order of the tree)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">A node with k keys must have exactly k+1 children</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Keys within a node are kept in sorted order</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This structure is particularly clever because it maps perfectly to how databases store data on disk. Each node is sized to fit in a single disk page (typically 8KB), maximizing our I/O efficiency. When PostgreSQL needs to find a record with id=350, it might only need to read 2-3 pages from disk: the root node, maybe an internal node, and finally a leaf node.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="real-world-examples">Real-World Examples</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">B-trees are everywhere in modern databases. PostgreSQL uses them for almost everything - primary keys, unique constraints, and most regular indexes are all B-trees.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When you create a table like this in PostgreSQL:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">TABLE</span><span> users </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>
</span><span>    id </span><span class="token" style="color: rgb(166, 38, 164);">SERIAL</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">PRIMARY</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">KEY</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    email </span><span class="token" style="color: rgb(166, 38, 164);">VARCHAR</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">255</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">UNIQUE</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">PostgreSQL automatically creates two B-tree indexes: one for the primary key and one for the unique email constraint. These B-trees maintain sorted order, which is crucial for both uniqueness checks and range queries.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">DynamoDB's sort key is also implemented as a B-tree variant, allowing for efficient range queries within a partition. This is why DynamoDB can efficiently handle queries like "find all orders for user X between date Y and Z" - the B-tree structure makes range scans fast.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Even MongoDB, with its document model, uses B-trees (specifically B+ trees, a variant where all data is stored in leaf nodes) for its indexes.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When you create an index in MongoDB like this:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>db</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span>users</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token" style="color: rgb(64, 120, 242);">createIndex</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token string-property" style="color: rgb(228, 86, 73);">"email"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You're creating a B-tree that maps email values to document locations.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="why-b-trees-are-the-default-choice">Why B-trees are the default choice</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">B-trees have become the default choice for most database indexes because they excel at everything databases need:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">They maintain sorted order, making range queries and ORDER BY operations efficient</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">They're self-balancing, ensuring predictable performance even as data grows</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">They minimize disk I/O by matching their structure to how databases store data</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">They handle both equality searches (email = 'x') and range searches (age &gt; 25) equally well</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">They remain balanced even with random inserts and deletes, avoiding the performance cliffs you might see with simpler tree structures</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you find yourself in an interview and you need to decide which index to use, B-trees are a safe bet.</div>
<div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="hash-indexes">Hash Indexes</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While B-trees dominate the indexing landscape, hash indexes serve a specialized purpose: they excel at exact-match queries. They're simply a persistent hashmap implementation - trading flexibility for blazing-fast O(1) lookups.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="how-hash-indexes-work">How Hash Indexes Work</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At their core, hash indexes are just a hashmap that maps indexed values to row locations. The database maintains an array of buckets, where each bucket can store multiple key-location pairs. When indexing a value, the database hashes it to determine which bucket should store the pointer to the row data.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/e8d66600ac90b77472168b64170a7218.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">hash-index</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For example, with a hash index on email:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>buckets</span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>hash</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(80, 161, 79);">"alice@example.com"</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span> -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>ptr to page </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>buckets</span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>hash</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(80, 161, 79);">"bob@example.com"</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>   -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>ptr to page </span><span class="token" style="color: rgb(183, 107, 1);">2</span><span class="token" style="color: rgb(56, 58, 66);">]</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Hash collisions are handled through linear probing - when a collision occurs, the database simply checks the next bucket until it finds an empty spot. While this means worst-case lookups can degrade to O(n), with a good hash function and load factor, we typically achieve O(1).</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This structure makes hash indexes incredibly fast for exact-match queries - just compute the hash, go to the bucket, and follow the pointer. However, this same structure makes them useless for range queries or sorting since similar values are deliberately scattered across different buckets.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="real-world-usage">Real-World Usage</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Despite their speed for exact matches, hash indexes are relatively rare in practice. PostgreSQL supports them but doesn't use them by default because B-trees perform nearly as well for exact matches while supporting range queries and sorting. As the PostgreSQL documentation notes, "B-trees can handle equality comparisons almost as efficiently as hash indexes."</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">However, hash indexes do shine in specific scenarios, particularly for in-memory databases. Redis, for example, uses hash tables as its primary data structure for key-value lookups because all data lives in memory. MySQL's MEMORY storage engine defaulted to hash indexes because in-memory exact-match queries were its primary use case. When working with disk-based storage, B-trees are usually the better choice due to their efficient handling of disk I/O patterns.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="when-to-choose-hash-indexes">When to Choose Hash Indexes</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In your system design interviews, you might consider hash indexes when:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You need the absolute fastest possible exact-match lookups</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You'll never need range queries or sorting</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You have plenty of memory (hash indexes tend to be larger than B-trees)</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But in most cases, B-trees will be the better choice. They're nearly as fast for exact matches and give you the flexibility to handle range queries when you need them. In the words of database expert Bruce Momjian: "Hash indexes solve a problem we rarely have."</div><div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Don't overemphasize hash indexes in an interview. While it's good to know about them, focusing too much on them might make you seem out of touch with real-world database practices. Remember, hash indexes are rarely used in production systems. They're a bit like that specialized kitchen gadget you buy and then use only once. B-trees are just so versatile that they cover most use cases where you might consider a hash index.</div></div></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="geospatial-indexes">Geospatial Indexes</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's an interesting quirk of system design interviews: while geospatial indexes are fairly specialized in practice - you might never touch them unless you're working with location data - they've become a common focus in interviews. Why? The rise of location-based services like Uber, Yelp, and Find My Friends has made proximity search a favorite interview topic.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="the-challenge-with-location-data">The Challenge with Location Data</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's say we're building a restaurant discovery app like Yelp. We have millions of restaurants in our database, each with a latitude and longitude. A user opens the app and wants to find "restaurants within 5 miles of me." Seems simple enough, right?</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The naive approach would be to use standard B-tree indexes on latitude and longitude:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">TABLE</span><span> restaurants </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>
</span><span>    id </span><span class="token" style="color: rgb(166, 38, 164);">SERIAL</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">PRIMARY</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">KEY</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    name </span><span class="token" style="color: rgb(166, 38, 164);">VARCHAR</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">255</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    latitude </span><span class="token" style="color: rgb(166, 38, 164);">DECIMAL</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">10</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">8</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    longitude </span><span class="token" style="color: rgb(166, 38, 164);">DECIMAL</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">11</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">8</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span>
<span></span><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_lat </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> restaurants</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>latitude</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_lng </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> restaurants</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>longitude</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But this falls apart quickly when we try to execute a proximity search. Think about how a B-tree index on latitude and longitude actually works. We're essentially trying to solve a 2D spatial problem (finding points within a circle) using two separate 1D indexes.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we query "restaurants within 5 miles," we'll inevitably hit one of two performance problems:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If we use the latitude index first, we'll find all restaurants in the right latitude range - but that's a long strip spanning the entire globe at that latitude! Then for each of those restaurants, we need to check if they're also in the right longitude range. Our index on longitude isn't helping because we're not doing a range scan - we're doing point lookups for each restaurant we found in the latitude range.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If we try to be clever and use both indexes together (via an index intersection), the database still has to merge two large sets of results - all restaurants in the right latitude range and all restaurants in the right longitude range. This creates a rectangular search area much larger than our actual circular search radius, and we still need to filter out results that are too far away.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/4905ac17226f25eff7122e911a4135b2.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">latlong</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is why we need indexes that understand 2D spatial relationships. Rather than treating latitude and longitude as independent dimensions, spatial indexes let us organize points based on their actual proximity in 2D space.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="core-approaches">Core Approaches</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There are three main approaches you'll encounter in interviews: geohashes, quadtrees, and R-trees. Each has its own strengths and trade-offs, but all solve our fundamental problem: they preserve spatial relationships in our index structure.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's explore each one, but remember - while this seems like a lot of specialized knowledge, interviewers mainly want to see that you understand the basic problem (why regular indexes fall short) and can reason about at least one solution. You don't need deep expertise in all three approaches unless you're interviewing for a role that specifically works with location data.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="geohash">Geohash</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's start with geohash - it's the simplest spatial index to understand and implement, which is why it's often the default choice in many databases. The core idea is beautifully simple: convert a 2D location into a 1D string in a way that preserves proximity.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/120714e3f0a9b61bc0eebadb147ef410.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Geohash</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Imagine dividing the world into four squares and labeling them 0-3. Then divide each of those squares into four smaller squares, and so on. Each division adds more precision to our location description. A geohash is essentially this process, but using a base32 encoding that creates strings like "dr5ru" for locations. The longer the string, the more precise the location:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">"dr" might represent all of San Francisco</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">"dr5" narrows it down to the Mission District</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">"dr5ru" might pinpoint a specific city block</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">What makes geohash clever is that locations that are close to each other usually share similar prefix strings. Two restaurants on the same block might have geohashes that start with "dr5ru", while a restaurant in a different neighborhood might start with "dr5rv".</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">And here's the real elegance: once we've converted our 2D locations into these ordered strings, we can use a regular B-tree index to handle our spatial queries. Remember how B-trees excel at prefix matching and range queries? That's exactly what we need for proximity searches.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we index the geohash strings with a B-tree:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_geohash </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> restaurants</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>geohash</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Finding nearby locations becomes as simple as finding strings with matching prefixes. If we're looking for restaurants near geohash "dr5ru", we can do a range scan in our B-tree for entries between "dr5ru" and "dr5ru~" (where ~ is the highest possible character). This lets us leverage all the optimizations that databases already have for B-trees - no special spatial data structure needed.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is why Redis's geospatial commands use this approach internally. When you run:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>GEOADD restaurants 37.7749 -122.4194 "Restaurant A"
</span>GEORADIUS restaurants -122.4194 37.7749 5 mi</code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Redis is using geohash under the hood to efficiently find nearby points. MongoDB also supports geohash-based indexes, though they abstract away the details.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The main limitation of geohash is that locations near each other in reality might not share similar prefixes if they happen to fall on different sides of a major grid division - like two restaurants on opposite sides of a street that marks a geohash boundary. But for most applications, this edge case isn't significant enough to matter.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This elegance - turning a complex 2D problem into simple string prefix matching that can leverage existing B-tree implementations - is why geohash is such a popular choice. It's easy to understand, implement, and use with existing database systems that already know how to handle strings efficiently.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="quadtree">Quadtree</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While less common in production databases today, quadtrees represent a fundamental tree-based approach to indexing 2D space that has shaped how we think about spatial indexing. Unlike geohash which transforms coordinates into strings, quadtrees directly partition space by recursively subdividing regions into four quadrants.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it works: Start with one square covering your entire area. When a square contains more than some threshold of points (typically 4-8), split it into four equal quadrants. Continue this recursive subdivision until reaching a maximum depth or achieving the desired point density per node:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>
</span>     C  
 A  
    B D

        
 E   F  
        
</code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This spatial partitioning maps to a tree structure:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/69d05d081130df81a6ef08ec54cf28f8.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Quadtree</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For proximity searches, navigate down the tree to find the target quadrant, check neighboring quadrants at the same level, and adjust the search radius by moving up or down tree levels as needed.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The key advantage of quadtrees is their adaptive resolution - dense areas get subdivided more finely while sparse regions maintain larger quadrants. However, unlike geohash which leverages existing B-tree implementations, quadtrees require specialized tree structures. This implementation complexity explains why most modern databases prefer geohash or R-tree variants.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So while they're not common in production nowadays, quadtrees have a significant impact on modern spatial indexing. The core concept of recursive spatial subdivision forms the foundation for R-trees, which optimize these ideas for disk-based storage and better handling of overlapping regions. You'll even find quadtree principles in modern mapping systems - Google Maps uses a similar structure for organizing map tiles at different zoom levels.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's explore how R-trees evolved these concepts into today's production standard for spatial indexing.</div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="r-tree">R-Tree</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">R-trees have emerged as the default spatial index in modern databases like PostgreSQL/PostGIS and MySQL. While both quadtrees and R-trees organize spatial data hierarchically, R-trees take a fundamentally different approach to how they divide space.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Instead of splitting space into fixed quadrants, R-trees work with flexible, overlapping rectangles. Where a quadtree rigidly divides each region into four equal parts regardless of data distribution, R-trees adapt their rectangles to the actual data. Think of organizing photos on a table - a quadtree approach would divide the table into equal quarters and keep subdividing, while an R-tree would let you create natural, overlapping groupings of nearby photos.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/eb6369dda6ee9c0795a949287b420e1f.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">R-tree</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When searching for nearby restaurants in San Francisco, an R-tree might first identify the large rectangle containing the city, then drill down through progressively smaller, overlapping rectangles until reaching individual restaurant locations. These rectangles aren't constrained to fixed sizes or positions - they adapt to wherever your data actually clusters. A quadtree, in contrast, would force you to navigate through a rigid grid of increasingly smaller squares, potentially requiring more steps to reach the same destinations.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This flexibility offers a crucial advantage: R-trees can efficiently handle both points and larger shapes in the same index structure. A single R-tree can index everything from individual restaurant locations to delivery zone polygons and road networks. The rectangles simply adjust their size to bound whatever shapes they contain. Quadtrees struggle with this mixed data - they keep subdividing until they can isolate each shape, leading to deeper trees and more complex traversal.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The trade-off for this flexibility is that overlapping rectangles sometimes force us to search multiple branches of the tree. Modern R-tree implementations use sophisticated algorithms to balance this overlap against tree depth, optimizing for how databases actually read data from disk. This balance of flexibility and disk efficiency is why R-trees have become the standard choice for production spatial indexes.</div><div class="my-6"><div class="MuiBox-root mui-1cy4qer"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you're asked about geospatial indexing in an interview, focus on explaining the problem clearly and contrasting a tree-based approach with a hash-based approach.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For example, you could say something like:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">"Traditional indexes like B-trees don't work well for spatial data because they treat latitude and longitude as independent dimensions. To efficiently search for nearby locations, we need an index that understands spatial relationships. Geohash is a hash-based approach that converts 2D coordinates into a 1D string, preserving proximity. This allows us to use a regular B-tree index on the geohash strings for efficient proximity searches.  However, tree-based approaches like R-trees can offer more flexibility and accuracy by grouping nearby objects into overlapping rectangles, creating a hierarchy of bounding boxes."</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">By contrasting these two approaches, you demonstrate a deeper understanding of the trade-offs involved in geospatial indexing.</div></div><div class="MuiBox-root mui-1gdegwm"></div><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeSmall MuiButton-textSizeSmall MuiButton-colorPrimary MuiButton-disableElevation MuiButton-root MuiButton-text MuiButton-textPrimary MuiButton-sizeSmall MuiButton-textSizeSmall MuiButton-colorPrimary MuiButton-disableElevation mui-149rsyb" tabindex="0" type="button">Show More<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-4 w-4"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="inverted-indexes">Inverted Indexes</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While B-trees excel at finding exact matches and ranges, they fall short when we need to search through text content. Consider what happens when you run a query like:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">SELECT</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">*</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">FROM</span><span> posts </span><span class="token" style="color: rgb(166, 38, 164);">WHERE</span><span> content </span><span class="token" style="color: rgb(64, 120, 242);">LIKE</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'%database%'</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here, we're looking for posts that contain the word "database" anywhere in their content - not just posts that start or end with it. Even with a B-tree index on the content column, the database can't use the index at all. Why? B-tree indexes can only help with prefix matches (like 'database%') or suffix matches (if you index the reversed content). When the pattern could match anywhere within the text, the database has no choice but to check every character of every post, reading entire text fields into memory to look for matches.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This full pattern matching gets exponentially slower as your text content grows. Each additional character in your posts means more data to scan, more memory to use, and more CPU cycles spent checking patterns. It's like trying to find every mention of a word in a library by reading every book, page by page.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">An inverted index solves this by flipping the relationship between documents and their content. Instead of storing documents with their words, it stores words with their documents. Think of it like the index at the back of a textbook - rather than reading every page to find mentions of "ACID properties", you can look up "ACID" and find every page that discusses it.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it works. Consider a simple blogging platform with these posts:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>doc1: </span><span class="token" style="color: rgb(80, 161, 79);">"B-trees are fast and reliable"</span><span>
</span><span>doc2: </span><span class="token" style="color: rgb(80, 161, 79);">"Hash tables are fast but limited"</span><span>
</span><span>doc3: </span><span class="token" style="color: rgb(80, 161, 79);">"B-trees handle range queries well"</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The inverted index creates a mapping:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>b-trees  -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc1, doc3</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>fast     -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc1, doc2</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>reliable -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc1</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span></span><span class="token" style="color: rgb(183, 107, 1);">hash</span><span>     -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc2</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>tables   -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc2</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>limited  -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc2</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>handle   -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc3</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>range    -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc3</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span>queries  -</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>doc3</span><span class="token" style="color: rgb(56, 58, 66);">]</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While this basic mapping shows the core concept, production inverted indexes are much more sophisticated. When systems like Elasticsearch index text, they first run it through an analysis pipeline that processes and enriches the content. This means:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Breaking text into tokens (words or subwords)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Converting to lowercase</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Removing common "stop words" like "the" or "and"</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Often applying stemming (reducing words to their root form)</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So when a user searches for "Databases", the system can match documents containing "database", "DATABASE", or even "database's". This is why full-text search feels so natural compared to rigid pattern matching.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Modern search systems like Elasticsearch and Lucene build additional sophistication on top of this foundation:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Term frequency analysis (how often words appear)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Relevance scoring (which documents best match the query)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Fuzzy matching (finding close matches like "databas")</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Phrase queries (matching exact sequences of words)</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice, you'll see inverted indexes whenever sophisticated text search is needed. When developers search GitHub repositories, when users search Slack message history, or when you search through documentation - they're all using inverted indexes under the hood.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There are still trade-offs, of course.Inverted indexes require substantial storage overhead and careful updating. When a document changes, you need to update entries for every term it contains. But for making text truly searchable, these are trade-offs we're willing to make.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You can learn more about how inverted indexes work in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/deep-dives/elasticsearch" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Elasticsearch Deep Dive</a>.</div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="index-optimization-patterns">Index Optimization Patterns</h2><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So far, we've explored the main types of indexes you'll encounter in system design interviews: B-trees for general-purpose querying, hash indexes for exact matches, geospatial indexes for location data, and inverted indexes for text search. Each type solves a specific class of problem, with trade-offs in storage, performance, and flexibility.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Experienced engineers spend significant time analyzing their application's read and write patterns, looking for ways to minimize the processing overhead of common queries. They identify performance bottlenecks by examining query plans and database metrics, then strategically optimize using appropriate indexing strategies. This often requires looking beyond just picking the right type of index - it's about understanding your access patterns and crafting an indexing approach that efficiently supports them.</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="composite-indexes">Composite Indexes</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Composite indexes are the most common optimization pattern you'll encounter in practice. Instead of creating separate indexes for each column, we create a single index that combines multiple columns in a specific order. This matches how we typically query data in real applications.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Consider a typical social media feed query:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">SELECT</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">*</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">FROM</span><span> posts 
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">WHERE</span><span> user_id </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">123</span><span> 
</span><span></span><span class="token" style="color: rgb(64, 120, 242);">AND</span><span> created_at </span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'2024-01-01'</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">ORDER</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">BY</span><span> created_at </span><span class="token" style="color: rgb(166, 38, 164);">DESC</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We could create two separate indexes:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_user </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> posts</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>user_id</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_time </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> posts</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>created_at</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But this isn't optimal. The database would need to:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Use one index to find all posts by user 123</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Use another index to find all posts after January 1st</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Intersect these results</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Sort the final result set by created_at</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Instead, a composite index gives us everything we need in one shot:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_user_time </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> posts</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>user_id</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> created_at</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we create a composite index, we're really creating a B-tree where each node's key is a concatenation of our indexed columns. For our (user_id, created_at) index, each key in the B-tree is effectively a tuple of both values. The B-tree maintains these keys in sorted order based on user_id first, then created_at. Conceptually, the keys might look like:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">1</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-01</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">1</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-02</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">1</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-03</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">2</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-01</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">2</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-02</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">3</span><span>, </span><span class="token" style="color: rgb(183, 107, 1);">2024</span><span>-01-01</span><span class="token" style="color: rgb(56, 58, 66);">)</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Now when we execute our query, the database can traverse the B-tree to find the first entry for user_id=123, then scan sequentially through the index entries for that user until it finds entries beyond our date range. Because the entries are already sorted by created_at within each user_id group, we get both our filtering and sorting for free.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This structure is particularly efficient because we're leveraging the B-tree's natural ordering to handle multiple conditions in a single index traversal. We've effectively turned our two-dimensional query (user and time) into a one-dimensional scan through ordered index entries.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/bc66d6ce1e4697676a3ab436a0e8a9e7.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">composite-index</span></div></div></div></div><h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="the-order-matters">The Order Matters</h4><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The order of columns in a composite index is crucial. Our index on (user_id, created_at) is great for queries that filter on user_id first, but it's not helpful for queries that only filter on created_at. This follows from how B-trees work - we can only use the index efficiently for prefixes of our column list.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is why you'll often hear database experts say "order columns from most selective to least selective." But there's more nuance in practice. Sometimes query patterns trump selectivity - if you frequently sort by a particular column, including it in your composite index (even if it's not highly selective) can eliminate expensive sort operations.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Consider common interview scenarios like:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Order history lookups: (customer_id, order_date)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Event processing: (status, priority, created_at)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Activity feeds: (user_id, type, timestamp)</div></li>
</ul><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="covering-indexes">Covering Indexes</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A covering index is one that includes all the columns needed by your query - not just the columns you're filtering or sorting on. Think about showing a social media feed with post timestamps and like counts. With a regular index on <span class="MuiBox-root mui-1vu004u">(user_id, created_at)</span>, the database first finds matching posts in the index, then has to fetch each post's full data page just to get the like count. That's a lot of extra disk reads just to display a number.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">By including the likes column directly in our index, we can skip those expensive page lookups entirely. The database can return everything we need straight from the index itself:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">TABLE</span><span> posts </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>
</span><span>    id </span><span class="token" style="color: rgb(166, 38, 164);">SERIAL</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">PRIMARY</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">KEY</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    user_id </span><span class="token" style="color: rgb(166, 38, 164);">INT</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    title </span><span class="token" style="color: rgb(166, 38, 164);">TEXT</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    content </span><span class="token" style="color: rgb(166, 38, 164);">TEXT</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    likes </span><span class="token" style="color: rgb(166, 38, 164);">INT</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    created_at </span><span class="token" style="color: rgb(166, 38, 164);">TIMESTAMP</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span>
<span></span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">-- Regular index</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_user_time </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> posts</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>user_id</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> created_at</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span>
<span></span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">-- Covering index includes likes column</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">CREATE</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">INDEX</span><span> idx_user_time_likes </span><span class="token" style="color: rgb(166, 38, 164);">ON</span><span> posts</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>user_id</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> created_at</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> INCLUDE </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span>likes</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre><div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">I'm using SQL as the examples given it's the most ubiquitous language for database interactions. But the same principles apply to other database systems and even NoSQL solutions.</div></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With the covering index, PostgreSQL can return results purely from the index data - no need to look up each post in the main table. This is especially powerful for queries that only need a small subset of columns from large tables.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The trade-off is, of course, size - covering indexes are larger because they store extra columns. But for frequently-run queries that only need a few columns, the performance boost from avoiding table lookups often justifies the storage cost. This is particularly true in social feeds, leaderboards, and other read-heavy features where query speed is critical.</div><div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The reality in 2025 is that covering indexes are more of a niche optimization than a go-to solution. Modern database query optimizers have become quite sophisticated at executing queries efficiently with regular indexes. While covering indexes can provide significant performance gains in specific scenarios - like read-heavy tables with limited columns - they come with real costs in terms of maintenance overhead and storage space.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In an interview, you may be wise to focus on simpler indexing strategies and, if reaching for covering indexes, be sure to make sure you have a good reason for why it's necessary.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you're not sure if they make sense in a given scenario, it's often better to err on the side of simplicity.</div></div></div></div></div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="wrapping-up">Wrapping Up</h2><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/717ce861b6d79113d0435c5bde5b4707.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Flowchart</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Indexes matter. Not just in interviews, but in production systems. Knowing how to use them effectively is a key skill for any developer and is knowledge that is regularly tested in interviews.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Most important is knowing when you need an index, and on what columns. This should be a natural instinct when you're designing a new schema. Consider the query patterns you're likely to run, and whether you'll be filtering or sorting on certain columns.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">From here, expect that you may be asked what type of index you would use for a given scenario. When in doubt, go with B-trees. They're the swiss army knife of indexes, handling both exact matches and range queries efficiently, and they're what most databases use by default for good reason.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The two main exceptions are when you're dealing with spatial data, or full-text search.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you're dealing with latitude and longitude, and need to efficiently search for nearby points, you'll want to opt for a geospatial index. If you only want to know one option, learn geohashing. Better still if you can explain how it works and weigh the tradeoffs between it and tree-based approaches.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Lastly, when it comes to full-text search, you'll need an inverted index to search large amounts of text efficiently. While it's unlikely you'll get deeply probed about how they work, you should have a basic understanding of the reverse mapping from keywords to documents.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With these tools in your toolbelt, you'll be well prepared for the overwhelming majority of indexing questions that may come your way.</div></div></div>
</body>
</html>