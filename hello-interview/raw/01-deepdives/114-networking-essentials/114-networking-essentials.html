<div id="markdown" class="mui-46nw7a"><div><div class="flex flex-col gap-2 md:gap-4"><div class="flex flex-col"><h6 class="MuiTypography-root MuiTypography-h6 mui-zfm63x">Core Concepts</h6><h1 class="MuiTypography-root MuiTypography-h2 mui-161snwm">Networking Essentials</h1><p class="MuiTypography-root MuiTypography-body2 mui-45a2r">Learn the important parts of networking that you'll need to know for your system design interviews</p></div></div><hr class="MuiDivider-root MuiDivider-fullWidth mui-1rvhejo"></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="intro">Intro</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Networking is a fundamental part of system design: you're nearly always going to be designing systems comprised of independent devices that communicate over a network. But the field of networking is vast and complex, and it's easy to get lost (this was one of the heaviest textbooks in school, gross).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In this guide we're going to cover the <strong>most important parts</strong> of networking that you'll need to know for your system design interviews. In later deep dives, patterns, and problem breakdowns, we'll build on these basics to solve for the problems you'll face as you design your systems.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">To do this, we'll start with the fundamentals of how networks operate, then examine key protocols at different layers of the networking stack. For each concept, we'll cover its purpose, how it works, and when to apply it in your system designs. Lots to cover so let's get to it!</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Networking tends to be a stronger focus in infrastructure and distributed systems interviews. For full-stack and product-focused roles, you'll likely only need a surface understanding of networking concepts. Understanding these fundamentals will help you make better decisions, even if the minute details aren't going to be tested in your interviews.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Each interviewer is a little different and if your interviewer just got off an oncall rotation dealing with load balancer problems or CDN issues, you'll want to be prepared to respond to their probes and questions!</div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="networking-101">Networking 101</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At its core, networking is about connecting devices and enabling them to communicate. Networks are built on a layered architecture (the so-called <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">"OSI model"</a>) which greatly simplifies the world for us application developers who sit on top of it.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Effectively, network layers are just abstractions that allow us to reason about the communication between devices in simpler terms relevant to our application. This way, when you're requesting a webpage, you don't need to know which voltages represent a <span class="MuiBox-root mui-1vu004u">1</span> or a <span class="MuiBox-root mui-1vu004u">0</span> on the network wire (modern networking hardware is even more sophisticated than this!) — you just need to know how to use the next layer down the stack. Think of it like how you might use <span class="MuiBox-root mui-1vu004u">open</span> in your language of choice instead of manually instructing the disk how to read bytes off a disk.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="networking-layers">Networking Layers</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While the full networking stack is fascinating, there are three key layers that come up most often in system design interviews. We're going to dive into each of them in a bit, but first let's talk about what these layers do and how they work together.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/6bb01bb714769449a8241058046be426.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">OSI Layers</span></div></div></div></div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="network-layer-layer-3">Network Layer (Layer 3)</h6>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At this layer is IP, the protocol that handles routing and addressing. It's responsible for breaking the data into packets, handling packet forwarding between networks, and providing best-effort delivery to any destination IP address on the network. While there are other protocols at this layer (like <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/InfiniBand" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">InfiniBand</a>, which is used extensively for massive ML training workloads), IP by far the most common for system design interviews.</div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="transport-layer-layer-4">Transport Layer (Layer 4)</h6>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At this layer, we have <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">TCP</a>, <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/QUIC" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">QUIC</a>, and <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">UDP</a>, which provide end-to-end communication services. Think of them like a layer that provides features like reliability, ordering, and flow control on top of the network layer.</div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="application-layer-layer-7">Application Layer (Layer 7)</h6>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At the final layer are the application protocols like DNS, HTTP, Websockets, WebRTC. These are common protocols that build on top of TCP to provide a layer of abstraction for different types of data typically associated with web applications. We'll cover them in depth.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">These layers work together to enable all our network communications. To see how they interact in practice, let's walk through a concrete example of how a simple web request works.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="example-a-simple-web-request">Example: A Simple Web Request</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When you type a URL into your browser, several layers of networking protocols spring into action. Let's break down how these layers work together to retrieve a simple web page over HTTP on TCP.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">First, we use <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">DNS</a> to convert a human-readable domain name like <span class="MuiBox-root mui-1vu004u">hellointerview.com</span> into an IP address like <span class="MuiBox-root mui-1vu004u">32.42.52.62</span>. Then, a series of carefully orchestrated steps begins. We set up a TCP connection over IP, send our HTTP request, get a response, and tear down the connection.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In detail:</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/96353ecdacd25e1f6b6a7fcd83faa8bb.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Simple HTTP Request</span></div></div></div></div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>DNS Resolution</strong>: The client starts by resolving the domain name of the website to an IP address using DNS (Domain Name System).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>TCP Handshake</strong>: The client initiates a TCP connection with the server using a three-way handshake:
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>SYN</strong>: The client sends a SYN (synchronize) packet to the server to request a connection.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>SYN-ACK</strong>: The server responds with a SYN-ACK (synchronize-acknowledge) packet to acknowledge the request.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>ACK</strong>: The client sends an ACK (acknowledge) packet to establish the connection.</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>HTTP Request</strong>: Once the TCP connection is established, the client sends an HTTP GET request to the server to request the web page.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Server Processing</strong>: The server processes the request, retrieves the requested web page, and prepares an HTTP response. (This is usually the only latency most SWE's think about and control!)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>HTTP Response</strong>: The server sends the HTTP response back to the client, which includes the requested web page content.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>TCP Teardown</strong>: After the data transfer is complete, the client and server close the TCP connection using a four-way handshake:
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>FIN</strong>: The client sends a FIN (finish) packet to the server to terminate the connection.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>ACK</strong>: The server acknowledges the FIN packet with an ACK.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>FIN</strong>: The server sends a FIN packet to the client to terminate its side of the connection.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>ACK</strong>: The client acknowledges the server's FIN packet with an ACK.</div></li>
</ul>
</div></li>
</ol>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">It's less common recently in BigTech, but it used to be a popular interview question to ask candidates to dive into the details of "what happens when you type (e.g.) <span class="MuiBox-root mui-1vu004u">hellointerview.com</span> into your browser and press enter?".</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Details like these aren't typically a part of a system design interview but it's helpful to understand the basics of networking. It may save you some headaches on the job!</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While the specific details of TCP handshakes and teardowns might seem too esoteric to apply to interviews, there's a few things to observe which we'll build upon:</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">First, as an application developer we are able to simplify our mental models dramatically. The application can take for granted that the data is transmitted with a degree of reliability and ordering: the TCP layer ensures that the data is delivered correctly and in order, and will provide a response to the application if it doesn't arrive. We also never have to concern ourselves with finding a specific server in the world and diving a pulse train of electrons to get there. With DNS, we can look up the IP address, and with IP the various networking hardware between us, our ISP, backbone providers, etc. can route the data to the destination. Nice!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Second, while we have one conceptual "request" and "response" here, there were many more packets and requests exchanged between servers to make it happen. All of these introduce latency that we can ignore ... until we can't. The higher in the stack we go, the more latency and processing required. This is relevant for our load balancer discussion shortly!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Finally note that the connection between the client and server is a <strong>state</strong> that both the client and server must maintain. Unless we use features like HTTP keep-alive or HTTP/2 multiplexing, we need to repeat this connection setup process for every request - a potentially significant overhead. This will becomes important for designing systems which need persistent connections, like those handling <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/deep-dives/realtime-updates" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Realtime Updates</a>.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="network-layer-protocols">Network Layer Protocols</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The first layer in our journey are the network layer protocols. This layer is dominated by the IP protocol, which is responsible for routing and addressing. In a system, nodes are assigned IPs usually by a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">DHCP server</a> when they boot up. These IP addresses are arbitrary and only mean something in as much as we tell people about them. If I want to, I can create a private network with my servers and give them any IP address I want, but if you want internet traffic to be able to find them you'll need to use IP addresses that are routable and allocated by a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Regional_Internet_Registry" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">RIR</a>.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">These assigned IP addresses are called <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Public_IP_address" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">public IPs</a> and are used to identify devices on the internet. The most important thing about them is that internet routing infrastructure is optimized to route traffic between public IPs and knows where they are. Any address starting with 17 (e.g. 17.0.0.0) is part of Apple — the backbone of the internet knows that when you want to send a packet to these addresses, you need to send it to their routers.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There's a lot more to cover in internet routing but it's not going to be important for our purposes so we'll keep it simple and move up the stack to our next layer: the transport layer.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="transport-layer-protocols">Transport Layer Protocols</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The transport layer is where we establish end-to-end communication between applications. They give us some some guarantees instead of handing us a jumbled mess of packets. The three primary protocols at this layer are TCP, UDP, and QUIC, each with distinct characteristics that make them suitable for different use cases.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For most system design interviews, the real choice you'll be faced with is <strong>between TCP and UDP</strong>. QUIC is a new protocol that aims to provide some of the same benefits of TCP with with some modernization and performance benefits. While QUIC is becoming more popular, it's still a relatively new protocol and not yet ubiquitous - for our purposes we'll consider it a better version of TCP but without the same broad baseline of adoption.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Some performance-oriented interviewers will be impressed by your knowledge of modern protocols like QUIC and HTTP/3, but most system design interviewers will want you to spend your time elsewhere in the design!</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="udp-fast-but-unreliable">UDP: Fast but Unreliable</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">User Datagram Protocol (UDP) is the machinegun of protocols. It offers few features on top of IP but is very fast. <strong>Spray and pray</strong> is the right way to think about this. It provides a simpler, connectionless service with no guarantees of delivery, ordering, or duplicate protection.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you write an application that receives UDP datagrams, you'll be able to see where they came from (i.e. the source IP address and port) and where they're going (i.e. the destination IP address and port). But that's it! The rest is a binary blob.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="key-characteristics-of-udp-include">Key characteristics of UDP include:</h4>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Connectionless</strong>: No handshake or connection setup</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>No guarantee of delivery</strong>: Packets may be lost without notification</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>No ordering</strong>: Packets may arrive in a different order than sent</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Lower latency</strong>: Less overhead means faster transmission</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">No setup sounds great but 2, 3, and 4 kinda suck, so why would you want to use UDP?</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">UDP is perfect for applications where <strong>speed is more important than reliability</strong>, such as live video streaming, online gaming, VoIP, and DNS lookups. In these cases the application or client is equipped to handle the occasional packet loss or out of order packet. For VOIP as an example, the client might just drop the occasional packet leading to a hiccup in the audio but overall the conversation is still intelligible. This is vastly preferable to retransmitting those lost packets and clogging up the network with ACKs.</div>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Browsers don't have widespread support for UDP yet outside of WebRTC (we'll get into it). If you're thinking about a design which could use UDP (like the spamming of hearts and reactions in <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/problem-breakdowns/fb-live-comments" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Facebook Live Comments</a>), think about what you'll do for your browser-based users. It might be that your app-based users get a real-time UDP stream of reactions while browser-based users a slower, batched HTTP stream which you spread out over time in the UI.</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="tcp-reliable-but-with-overhead">TCP: Reliable but with Overhead</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Transmission Control Protocol (TCP) is the workhorse of the internet. It provides reliable, ordered, and error-checked delivery of data. It establishes a connection through a three-way handshake (we saw this illustrated above with the HTTP example) and maintains that connection throughout the communication session.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This connection is called a "stream" and is a <strong>stateful connection</strong> between the client and server — it also gives us a basis to talk about ordering: two messages sent in the same stream/connection will arrive in the same order. TCP will ensure that recipients of messages acknowledge their receipt and, if they don't, will retransmit the message until it is acknowledged.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="key-characteristics-of-tcp">Key Characteristics of TCP</h4>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Connection-oriented</strong>: Establishes a dedicated connection before data transfer</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Reliable delivery</strong>: Guarantees that data arrives in order and without errors</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Flow control</strong>: Prevents overwhelming receivers with too much data</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Congestion control</strong>: Adapts to network congestion to prevent collapse</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">TCP is ideal for applications where data integrity is critical — that is, <strong>basically everything where UDP is not a good fit</strong>.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="when-to-choose-each-protocol">When to Choose Each Protocol</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In system design interviews, most interviewers will expect you're using TCP by default — it often doesn't need to be directly mentioned. That's good because that's also our recommendation!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But you'll be able to earn extra points if you can make the case for a UDP application and not bungle the details. So the question you should be asking yourself is whether UDP is a better fit for your use-case.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You might choose <strong>UDP</strong> when:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Low latency is critical (real-time applications, gaming)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Some data loss is acceptable (media streaming)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You're handling high-volume telemetry or logs where occasional loss is acceptable</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You don't need to support web browsers (or you have an alternative for that client)</div></li>
</ul>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Modern applications often use both protocols. For example, a web-based video conferencing app might use TCP/HTTP for signaling and authentication but UDP/WebRTC for the actual audio/video streams.</div></div></div></div></div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="tcp-vs-udp-comparison">TCP vs UDP Comparison</h4>
<div class="MuiTableContainer-root mui-ntrpdu"><table class="MuiTable-root mui-hu1vpi"><thead class="MuiTableHead-root mui-1wbz3t9"><tr class="MuiTableRow-root MuiTableRow-head mui-a1y8t3"><th class="MuiTableCell-root MuiTableCell-head MuiTableCell-sizeSmall mui-1dvcw2j" scope="col">Feature</th><th class="MuiTableCell-root MuiTableCell-head MuiTableCell-sizeSmall mui-1dvcw2j" scope="col">UDP</th><th class="MuiTableCell-root MuiTableCell-head MuiTableCell-sizeSmall mui-1dvcw2j" scope="col">TCP</th></tr></thead><tbody class="MuiTableBody-root mui-1xnox0e"><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Connection</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Connectionless</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Connection-oriented</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Reliability</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Best-effort delivery</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Guaranteed delivery</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Ordering</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">No ordering guarantees</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Maintains order</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Flow Control</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">No</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Yes</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Congestion Control</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">No</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Yes</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Header Size</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">8 bytes</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">20-60 bytes</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Speed</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Faster</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Slower due to overhead</td></tr><tr class="MuiTableRow-root mui-a1y8t3"><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Use Cases</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Streaming, gaming, VoIP</td><td class="MuiTableCell-root MuiTableCell-body MuiTableCell-sizeSmall mui-7wgons">Everything Else</td></tr></tbody></table></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="application-layer-protocols">Application Layer Protocols</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The application layer is where most developers spend their time. These protocols define how applications communicate and are built on top of the transport layer protocols we just discussed.</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Typically the application layer is processed in <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">"User Space"</a> whereas layers beneath it are processed in the OS kernel in "Kernel Space". This means that the application layer is more flexible and can be more easily modified than lower layers, whereas lower layers are difficult to change but can be <em>very</em> efficient.</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="httphttps-the-webs-foundation">HTTP/HTTPS: The Web's Foundation</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Hypertext Transfer Protocol (HTTP) is the de-facto standard for data communication on the web. It's a request-response protocol where clients send requests to servers, and servers respond with the requested data.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">HTTP is a stateless protocol, meaning that each request is independent and the server doesn't need to maintain any information about previous requests. This is generally a good thing. In system design you'll want to minimize the surface area of your system that needs to be stateful where possible. Most simple HTTP servers can be described as a function of the request parameters — they're stateless!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's a simple HTTP request/response. You can actually open up a TCP connection and send an HTTP request/response by hand with <span class="MuiBox-root mui-1vu004u">nc</span> if you'd like!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/ac33e3c6e3e40a718fd07c5196be1f5a.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Simple HTTP Request/Response</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You'll see a few key concepts:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Request methods</strong>: GET, POST, PUT, DELETE, etc.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Status codes</strong>: 200 OK, 404 Not Found, 500 Server Error, etc.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Headers</strong>: Metadata about the request or response</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Body</strong>: The actual content being transferred</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The HTTP request methods and status codes are well-defined and standardized (think of them like enums). It's good to know some of the common ones, but most interviewers aren't going to get into this level of detail except if you're using a RESTful API.</div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="common-request-methods">Common Request Methods</h6>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">GET</span>: Request data from the server. GET requests should be idempotent and don't have a body.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">POST</span>: Send data to the server.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">PUT</span>: Update data on the server.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">PATCH</span>: Update a resource partially.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">DELETE</span>: Delete data from the server. DELETE requests should be idempotent.</div></li>
</ul>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="common-status-codes">Common Status Codes</h6>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Success (2xx)
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">200 OK</span>: The request was successful</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">201 Created</span>: The request was successful and a new resource was created</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Moved (3xx)
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">302 Found</span>: The requested resource has been moved temporarily</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">301 Moved Permanently</span>: The requested resource has been moved permanently</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Client Error (4xx)
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">404 Not Found</span>: The requested resource was not found</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">401 Unauthorized</span>: The request requires authentication</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">403 Forbidden</span>: The server understood the request but refuses to authorize it</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">429 Too Many Requests</span>: The client has sent too many requests in a given amount of time</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Server Error (5xx)
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">500 Server Error</span>: The server encountered an error</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><span class="MuiBox-root mui-1vu004u">502 Bad Gateway</span>: The server received an invalid response from the upstream server</div></li>
</ul>
</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The headers are much more flexible (think of them like key/value pairs). This flexibility demonstrates the pragmatic design philosophy that underlies much of the HTTP spec.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">HTTP headers are a great example of how to design an interface that is flexible to unknown future use-cases and provides a good lesson for API design. Content negotiation is a perfect case study.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The HTTP <span class="MuiBox-root mui-1vu004u">Accepts-Encoding</span> header as an example provides clients a way to indicate they can handle different types of content encoding. This allows servers to provide (e.g.) <span class="MuiBox-root mui-1vu004u">gzip</span> or <span class="MuiBox-root mui-1vu004u">br</span> (brotli) encoded responses if they're available. Servers can then respond with the most efficient encoding for that client with <span class="MuiBox-root mui-1vu004u">Content-Encoding: X</span>  providing both backward compatibility and graceful degradation.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">HTTPS adds a security layer (TLS/SSL) to encrypt communications, protecting against eavesdropping and man-in-the-middle attacks. If you're building a public website you're going to be using HTTPS without exception. Generally speaking this means that the contents of your HTTP requests and responses are encrypted and safe in transit.</div>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While the contents of your HTTPS requests and responses are encrypted, they aren't guaranteed to be generated by your client! Your API should never trust the contents of the request body without validating it. A common mistake is to include the user's ID in the request body and use it to make a database call. If an attacker can change the request body, they can change the user ID and read arbitrary user data. Ouch!</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This doesn't mean you can't include user IDs in your requests. It just means you need to be able to validate them on the server and your API shouldn't ask for anything you can't trust.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">That's HTTP in a nutshell! Now let's talk about how to use it to build APIs.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="rest-simple-and-flexible">REST: Simple and Flexible</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While HTTP can be used directly to build <em>websites</em>, oftentimes system designs are concerned with the communication between <em>services</em> via APIs. For creating these APIs, we have three main paradigms: REST, GraphQL, and gRPC.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">REST is the most common API paradigm you'll use in system design interviews. It's a simple and flexible way to create APIs that are easy to understand and use. The core principle behind REST is that clients are often performing simple operations against <strong>resources</strong> (think of them like database tables or files on a server).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In RESTful API design, the primary challenge is to model your resources and the operations you can perform on them. RESTful API's take advantage of the HTTP methods or verbs together with some opinionated conventions about the paths and the body of the request. They often use JSON to represent the resources in both the request and response bodies — although it's not strictly required.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you've followed our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/in-a-hurry/delivery-framework" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Delivery Framework</a>, your Core Entities will oftentimes map directly to the resources in your API. Bonus!</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A simple RESTful API might look like this (where <span class="MuiBox-root mui-1vu004u">User</span> is a JSON object representing a user):</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(183, 107, 1);">GET</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">/</span><span>users</span><span class="token" style="color: rgb(64, 120, 242);">/</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>id</span><span class="token" style="color: rgb(56, 58, 66);">}</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">-</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> User</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here we're using the HTTP method "GET" to indicate that we're requesting a resource. The <span class="MuiBox-root mui-1vu004u">{id}</span> is a placeholder for the resource ID, in this case the user ID of the user we want to retrieve.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we want to update that user, we can use the HTTP method "PUT" to indicate that we're updating a pre-existing resource.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(183, 107, 1);">PUT</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">/</span><span>users</span><span class="token" style="color: rgb(64, 120, 242);">/</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>id</span><span class="token" style="color: rgb(56, 58, 66);">}</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">-</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> User
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token string-property" style="color: rgb(228, 86, 73);">"username"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"john.doe"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token string-property" style="color: rgb(228, 86, 73);">"email"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"john.doe@example.com"</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can also create new resources by using the HTTP method "POST". We'll include the body the content of the resource we want to create. Note that I'm not specifying an ID here because the server will assign one.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(183, 107, 1);">POST</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">/</span><span>users </span><span class="token" style="color: rgb(64, 120, 242);">-</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> User
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token string-property" style="color: rgb(228, 86, 73);">"username"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"stefan.mai"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token string-property" style="color: rgb(228, 86, 73);">"email"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"stefan@hellointerview.com"</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Finally, resources can be nested to represent relationships between resources. For example, a user might have many posts, so we can represent that relationship by nesting the posts under the user resource.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(183, 107, 1);">GET</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">/</span><span>users</span><span class="token" style="color: rgb(64, 120, 242);">/</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>id</span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(64, 120, 242);">/</span><span>posts </span><span class="token" style="color: rgb(64, 120, 242);">-</span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>Post</span><span class="token" style="color: rgb(56, 58, 66);">]</span></code></div></div></pre>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Many engineers often think in terms of methods like <span class="MuiBox-root mui-1vu004u">updateUser</span> or <span class="MuiBox-root mui-1vu004u">startGame</span>. These are operations, not resources, so they're not RESTful.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In REST, we want to think in terms of resources and the operations you can perform on them. So our <span class="MuiBox-root mui-1vu004u">updateUser</span> might be <span class="MuiBox-root mui-1vu004u">PUT /users/{id}</span> and our <span class="MuiBox-root mui-1vu004u">startGame</span> might be <span class="MuiBox-root mui-1vu004u">PATCH /games</span> with <span class="MuiBox-root mui-1vu004u">{ "status": "started" }</span>.</div></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Overall REST is very flexible for a wide variety of use-cases and applications. <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/deep-dives/elasticsearch" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">ElasticSearch</a> uses it to manage documents, configure indexes, and more. Check out that deep dive if you want to see a great example of a RESTful API.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">REST is <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://medium.com/@i.gorton/scaling-up-rest-versus-grpc-benchmark-tests-551f73ed88d4" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">not going to be the most performant solution</a> for very high throughput services, and generally speaking JSON is a pretty inefficient format for serializing and deserializing data.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">That said, most applications aren't going to be bottlenecked by request serialization. Like TCP, <strong>REST is where we'd suggest you default for your interviews</strong>. It's well-understood and a good baseline for building scalable systems. You should reach for GraphQL, gRPC, SSE, or WebSockets if you have specific needs that REST can't meet.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="graphql-flexible-data-fetching">GraphQL: Flexible Data Fetching</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">GraphQL is a more recent API paradigm (open-sourced circa 2015 by Facebook) that allows clients to request exactly the data they need.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's the problem GraphQL solves: Frequently teams and systems are organized into frontend and backend. As an example, the frontend might be a mobile app and the backend a database-based API.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When the frontend team wants to display a new page, they can either (a) cobble together a bunch of different requests to backend endpoints (imagine querying 1 API for a list of users and making 10 API calls to get their details), (b) create huge aggregation APIs which are hard to maintain and slow to change, or (c) write brand new APIs for every new page they want to display. <em>None of these are particularly good solutions</em> but it's easy to run into them with a standard REST API.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The problem with under-fetching is that you may need multiple requests and round trips. This adds overhead and latency to the page load.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/f1ef6941817ed05f1dc6c2dbdd7ff8f8.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Under-Fetching Example - Page requires a lot of API calls to render</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Over-fetching is the opposite: when we pack way more than we need in an API response to guard ourselves against future use-cases that we don't have today. It means that APIs take a long time to load and return too much data.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/ce0bdf6d1dcccbd6b753f78bcf67e0df.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Over-Fetching Example - Results take too long and have far more data than the frontend needs</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">And writing brand new APIs for every new page is a nightmare.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">GraphQL solves these problems by allowing the frontend team to flexibly query the backend for exactly the data they need. The backend can then respond with the data in the shape that the frontend needs it. This is a great fit for mobile apps and other use-cases where you want to reduce the amount of data transferred.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's an example of a GraphQL query which fetches just the data the frontend needs for a sophisticated page which shows both users with their profiles and groups they're a member of.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">query</span><span> </span><span class="token definition-query" style="color: rgb(64, 120, 242);">GetUsersWithProfilesAndGroups</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(64, 120, 242);">$limit</span><span class="token" style="color: rgb(56, 58, 66);">:</span><span> </span><span class="token scalar">Int</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">10</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">$offset</span><span class="token" style="color: rgb(56, 58, 66);">:</span><span> </span><span class="token scalar">Int</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">0</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token property-query">users</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">limit</span><span class="token" style="color: rgb(56, 58, 66);">:</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">$limit</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">offset</span><span class="token" style="color: rgb(56, 58, 66);">:</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">$offset</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token" style="color: rgb(228, 86, 73);">id</span><span>
</span><span>    </span><span class="token" style="color: rgb(228, 86, 73);">username</span><span>
</span><span>    //</span><span class="token" style="color: rgb(64, 120, 242);">...</span><span>
</span>    
<span>    </span><span class="token fragment" style="color: rgb(64, 120, 242);">profile</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">id</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">fullName</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">avatar</span><span>
</span><span>      // </span><span class="token" style="color: rgb(64, 120, 242);">...</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span>    
<span>    </span><span class="token object">groups</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">id</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">name</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">description</span><span>
</span><span>      // </span><span class="token" style="color: rgb(64, 120, 242);">...</span><span>
</span>      
<span>      </span><span class="token fragment" style="color: rgb(64, 120, 242);">category</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>        </span><span class="token" style="color: rgb(228, 86, 73);">id</span><span>
</span><span>        </span><span class="token" style="color: rgb(228, 86, 73);">name</span><span>
</span><span>        </span><span class="token" style="color: rgb(228, 86, 73);">icon</span><span>
</span><span>      </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span>    
<span>    </span><span class="token object">status</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">isActive</span><span>
</span><span>      </span><span class="token" style="color: rgb(228, 86, 73);">lastActiveAt</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span>  
<span>  </span><span class="token object">_metadata</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token" style="color: rgb(228, 86, 73);">totalCount</span><span>
</span><span>    </span><span class="token" style="color: rgb(228, 86, 73);">hasNextPage</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The graphQL code here is basically specifying which fields and nested objects we want to fetch. The backend can interpret this query and respond with just the data the frontend needs.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In our example, instead of writing a bunch of different APIs, the frontend team can just write a single query to get the data they need and the backend can (in theory) respond with the data in the shape that the frontend needs it.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="where-to-use-it-1">Where to Use It</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">GraphQL is a great fit for use-cases where the frontend team needs to iterate quickly and adjust. They can flexibly query the backend for exactly the data they need. On the other hand, execution of these GraphQL queries can be a source of latency and complexity for the backend — sometimes involving the same bespoke backend code that we're trying to avoid. In practice, GraphQL finds its sweet spot with complex clients and when multiple teams are making wide queries to overlapping data.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For system design interviews specifically, the benefits of GraphQL are murky. In the interview you'll have a fixed set of requirements (not the moving targets of iterating on a mobile app or web frontend) where GraphQL starts to shine. Additionally, the interviewer will frequently want to see how you optimize specific query patterns and while you can talk about custom resolvers — GraphQL is frequently just in the way.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We recommend bringing up GraphQL in cases where the problem is clearly focused on flexibility (e.g. the interviewer tells us we need to be able to adapt our apps quickly to changing requirements) or when the requirements in the interview are deliberately uncertain.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="grpc-efficient-service-communication">gRPC: Efficient Service Communication</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">gRPC is a high-performance RPC (Remote Procedure Call) framework from Google (the "g") that uses HTTP/2 and Protocol Buffers.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Think of Protocol Buffers like JSON but with a more rigid schema that allows for better performance and more efficient serialization. Here's an example of a Protocol Buffer definition for a <span class="MuiBox-root mui-1vu004u">User</span> resource:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">message</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">User</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(80, 161, 79);">string</span><span> id </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span>  </span><span class="token" style="color: rgb(80, 161, 79);">string</span><span> name </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">2</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Instead of a chunky JSON object with embedded schema (40 bytes) ...</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(228, 86, 73);">"id"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"123"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token" style="color: rgb(228, 86, 73);">"name"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"John Doe"</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">... we have a binary encoding (15 bytes) of the same data with very skinny tags and variable length encoding of the strings. Less space and less CPU to parse!</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>0A 03 31 32 33 12 08 6A 6F 68 6E 20 64 6F 65</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">gRPC builds on this to provide service definitions. Here's an example of a gRPC service definition for a <span class="MuiBox-root mui-1vu004u">UserService</span>:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">message</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">GetUserRequest</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(80, 161, 79);">string</span><span> id </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span>
<span></span><span class="token" style="color: rgb(166, 38, 164);">message</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">GetUserResponse</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token positional-class-name" style="color: rgb(183, 107, 1);">User</span><span> user </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span>
<span></span><span class="token" style="color: rgb(166, 38, 164);">service</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">UserService</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(166, 38, 164);">rpc</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">GetUser</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">GetUserRequest</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">returns</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(183, 107, 1);">GetUserResponse</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">I probably don't need to explain the details of this to you!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">These definitions are compiled into a client and server stub which a wide variety of languages and frameworks can consume to build services and clients. gRPC includes a bunch of features relevant for operating microservice architectures at scale (it was invented by Google after all) like streaming, deadlines, client-side load balancing and more. But the most important thing to know is that it's a binary protocol that's faster and more efficient than JSON over HTTP.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-2">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">gRPC shines in microservices architectures where services need to communicate efficiently. Its strong typing helps catch errors at compile time rather than runtime, and its binary protocol is more efficient than JSON over HTTP (<a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://medium.com/@i.gorton/scaling-up-rest-versus-grpc-benchmark-tests-551f73ed88d4" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">some benchmarks show a factor of 10x throughput!</a>). Consider gRPC for internal service-to-service communication, especially when performance is critical or when latencies are dominated by the network rather than the work the server is doing.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">That said, you generally won't use gRPC for public-facing APIs, especially for clients you don't control, because it's a binary protocol and the tooling for working with it is less mature than simple JSON over HTTP. Having internal APIs using gRPC and external APIs using REST is a great way to get the benefits of a binary protocol without the complexity of a public-facing API. There are definitely engineers who would love it if gRPC was more widely adopted, but it's not there yet.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/b420785ea9c9351c2f45a50d4982b912.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Example of Using gPRC for Internal APIs, and REST and HTTP for External</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">As such, <strong>we recommend using REST for public-facing APIs and leaving gRPC for internal service-to-service communication</strong> — especially if binary data is being exchanged or performance is critical. In many interviews, using REST both for internal and external APIs is fine and you can build from there depending on the needs of the problem and probes from your interviewer.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Sometimes engineers think the point of a system design interview is to draw up an optimal solution to a problem on a whiteboard. But interviewers typically are trying to understand how you think through a problem and how you react to challenges and constraints you may not have seen before. Be weary of hyperoptimizing your RPC protocol choice before you've handled other substantial bottlenecks in the problem. Premature optimization is the root of all evil!</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="server-sent-events-sse-real-time-push-communication">Server-Sent Events (SSE): Real-Time Push Communication</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So far we've been talking mostly about request/response style APIs, but many applications need to "push" data to clients in a more streaming fashion. While gRPC does support streaming, it's not ideal for external APIs due to limited support (e.g. no browsers support gRPC today). Server-Sent Events (SSE) is a spec defined on top of HTTP that allows a server to push many messages to the client over a single HTTP connection.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how to think of it: SSE is a nice hack on top of HTTP that <strong>allows a server to stream many messages, over time, in a single response from the server</strong>.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With most HTTP APIs you'd get a single, cohesive JSON blob as a response from the server that is processed once the whole thing has been received.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(228, 86, 73);">"events"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"id"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">1</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"timestamp"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"2025-01-01T00:00:00Z"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"description"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"Event 1"</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"id"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">2</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"timestamp"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"2025-01-01T00:00:01Z"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"description"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"Event 2"</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span>    ...
<span>    </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"id"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">100</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"timestamp"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"2025-01-01T00:00:10Z"</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(228, 86, 73);">"description"</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">"Event 100"</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Since we have to wait for the whole response to come in before we can process it, it's not much good for push notifications!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">On the other hand, with SSE, the server can push many messages as "chunks" in a single response from the server:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>data: {"id": 1, "timestamp": "2025-01-01T00:00:00Z", "description": "Event 1"}
</span>data: {"id": 2, "timestamp": "2025-01-01T00:00:01Z", "description": "Event 2"}
...
data: {"id": 100, "timestamp": "2025-01-01T00:00:10Z", "description": "Event 100"}</code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Each line here is received as a separate message from the server. The client can then process each message as it comes in. It's still one big HTTP response (same TCP connection), but it comes in over many smaller packets and clients are expected to process each line of the body individually to allow them to react to the data as it comes in.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Now with all good hacks, SSE comes with some acute limitations. We can't keep an SSE connection open for too long because the server (or the load balancer, or a middle box proxy) will close down the connection. So the SSE standard defines the behavior of an <span class="MuiBox-root mui-1vu004u">EventSource</span> object that, once the connection is closed, will automatically reconnect with the ID of the last message received. Servers are expected to fill keep track of prior messages that may have been missed while the client was disconnected and resend them.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice there are also some nasty, misbehaving networks that will batch up all SSE responses into a single response <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://dev.to/miketalbot/server-sent-events-are-still-not-production-ready-after-a-decade-a-lesson-for-me-a-warning-for-you-2gie" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">making it behave a lot like what we're trying to avoid</a>. Tradeoffs!</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Most interviewers are not familiar with these limitations and will gladly let you assume they don't exist. But it's good to be aware of them because anyone who has actually implemented SSE has an enduring headache from these issues and will try to get a sense for whether you've actually used it in practice.</div></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-3">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You'll find SSE useful in system design interviews in situations where you want clients to get notifications or events as soon as they happen. SSE is a great option for <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/problem-breakdowns/online-auction#3-how-can-we-ensure-that-the-system-displays-the-current-highest-bid-in-real-time" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">keeping bidders up-to-date on the current price of an auction</a>, for example.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We touch on this pattern in greater detail in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/deep-dives/realtime-updates" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Realtime Updates</a> deep dive, which also covers the server-side implications of an SSE implementation.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="websockets-real-time-bidirectional-communication">WebSockets: Real-Time Bidirectional Communication</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Now while SSE is a great way to push from the server to client, many applications need real-time bidirectional communication. And while gRPC does support streaming, it's still (broken record?) not ideal for external APIs due to limited support (e.g. no browsers support gRPC today). So what's an interview candidate to do?</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Enter WebSockets! WebSockets provide a persistent, TCP-style connection between client and server, allowing for real-time, bidirectional communication with broad support (including browsers). Unlike HTTP's request-response model, WebSockets enable servers to <strong>push</strong> data to clients without being prompted by a new request. Similarly clients can push data back to the server without the same wait.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">WebSockets are initiated via an HTTP "upgrade" protocol, which allows an existing TCP connection to change L7 protocols. This is super convenient because it means you can utilize some of the existing HTTP session information (e.g. cookies, headers, etc.) to your advantage.</div>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Just because clients can upgrade from HTTP to WebSocket doesn't mean that the infrastructure will support it. Every piece of infrastructure between the client and server will need to support WebSocket connections.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you've ever implemented Websockets you've probably hit a bunch of issues with firewalls, proxies, load balancers, and other infrastructure that don't support WebSocket connections.</div></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="how-it-works">How it Works</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it works:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Client initiates WebSocket handshake over HTTP (with a backing TCP connection)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Connection upgrades to WebSocket protocol, WebSocket takes over the TCP connection</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Both client and server can send binary messages to each other over the connection</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The connection stays open until explicitly closed</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">WebSockets don't dictate an application protocol, you effectively have a channel where you can send binary packets to the server from the client and vice versa. This means you'll need some way of defining what it is your client and server are exchanging. For many WebSocket applications, simple serialized JSON messages are a great option! This also gives you a chance to define the API of your service for your design:</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/7a81427ffd4b856be04e6ce380a19181.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">WebSocket API Example</span></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-4">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">WebSockets come up in system design interviews when you need <strong>high-frequency</strong>, <strong>persistent</strong>, <strong>bi-directional</strong> communication between client and server. Think real-time applications, games, and other use-cases where you need to send and receive messages as soon as they happen.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For applications where either you just need to be able to send requests and receive responses, or situations where you can make due with the push notifications provided by SSE, WebSockets are overkill.</div>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In system design interviews, launching into a WebSocket implementation without justifying why they are needed is a great way to get a "thumbs down" from your interviewer. WebSockets are powerful, but the infra required to support them can be expensive and the overhead of stateful connections (especially at scale) will require significant accommodations in your design. Hold off unless you really need them!</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="webrtc-peer-to-peer-communication">WebRTC: Peer-to-Peer Communication</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The last protocol we'll cover is the most unique. WebRTC enables direct peer-to-peer communication between browsers without requiring an intermediary server for the data exchange. WebRTC can be perfect for collaborative applications like document editors and is especially useful for video/audio calling and conferencing applications. Oh, and it's the only application-level protocol we'll cover that uses UDP!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The WebRTC spec is comprised of several pieces of infra and protocols that are necessary to establish a peer-to-peer connection between browsers. From a networking perspective, peer-to-peer connections are more complex than the client-server models we've been discussing so far because most clients don't allow inbound connections for security reasons.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With WebRTC, clients talk to a central "signaling server" which keeps track of which peers are available together with their connection information. Once a client has the connection information for another peer, they can try to establish a direct connection without going through any intermediary servers.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice, most clients don't allow inbound connections for security reasons and the majority of users are behind a NAT (network address translation) device which keeps them from being connected to directly. So if we stopped there, most peers wouldn't be able to "speak" to each other.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The WebRTC standard includes two methods to work around these restrictions:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>STUN</strong>: "Session Traversal Utilities for NAT" is a protocol and a set of techniques like "hole punching" which allows peers to establish publically routable addresses and ports. I won't go into details here, but as hacky as it sounds it's a standard way to deal with NAT traversal and it involves repeatedly creating open ports and sharing them via the signaling server with peers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>TURN</strong>: "Traversal Using Relays around NAT" is effectively a relay service, a way to bounce requests through a central server which can then be routed to the appropriate peer.</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/2ed45da031caf1bbe56c1055aee02270.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">WebRTC Setup</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There's effectively 4 steps to a WebRTC connection:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Clients connect to a central signaling server to learn about their peers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Clients reach out to a STUN server to get their public IP address and port.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Clients share this information with each other via the signaling server.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Clients establish a direct peer-to-peer connection and start sending data.</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is the happy case! In reality, sometimes these connections fail and you need to have fallbacks like our TURN server.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-5">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">WebRTC is ideal for audio/video calling and conferencing applications (we use it for our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/mock/overview" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Mock Interviews</a>). It can also occasionally be appropriate for collaborative applications like document editors, especially if they need to scale to many clients.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice, most collaborative editors <em>don't</em> require scaling to thousands of clients. Additionally, you often need a central server anyways to store the document and coordinate between clients. That's why we're using Websockets in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/problem-breakdowns/google-docs" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Google Docs problem breakdown</a>. But there is an alternative that used WebRTC and CRDTs (Conflict-free Replicated Data Types) to achieve a truly peer-to-peer experience.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For interviews, we suggest sticking to WebRTC for video/audio calling and conferencing applications.</div>
<div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">WebRTC is an absolute pain to get right and even the best implementations still suffer connection losses. It truly is a niche solution.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In interviews, I've seen more candidates go wildly off trail trying to design peer-to-peer systems using WebRTC than I have seen them successfully implement them. Most problems <em>don't</em> require peer-to-peer connections and it's easy to try to wrap a solution around a problem that doesn't actually need it.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you stick to only using WebRTC for video/audio calling and conferencing, you'll be in good shape.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There's way more to cover around WebRTC than is appropriate for this guide <em>or</em> your interview so we'll stop here, but I hope this gives you a good starting point for thinking about this protocol!</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="load-balancing">Load Balancing</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">And with that we've covered the top of our stack and all the relevant protocols you'll see in System Design interviews. But how do we <strong>scale</strong> our designs? Of course there are networking implications here!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For scaling, we have two options: bigger servers (vertical scaling) or more servers (horizontal scaling).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/8c4b2f019b4bacf292acaae016267b77.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Vertical vs Horizontal Scaling</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">My personal preference is to employ vertical scaling wherever possible. Modern hardware is incredibly powerful and the days of requiring thousands of tiny servers when a few larger ones can handle the load are over (read more about modern hardware capabilities in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/deep-dives/numbers-to-know" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Numbers to Know</a> deep dive).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">That said, the reality for <em>interviews</em> is that <strong>the most common pattern for scaling you'll see is horizontal scaling</strong>: we're going to add more servers to handle the load. But just adding boxes to our whiteboard won't help if we don't tell our clients which server to talk to.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Enter: Load Balancing.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/94a7bdf8bbf714c60d20e1daf817ca34.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">How do we route our traffic?</span></div></div></div></div>


<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="types-of-load-balancing">Types of Load Balancing</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We need to spread the incoming requests (load) by deciding which server should handle each request. There's two ways to handle load balancing: on the client side or on the server side. Both have their pros and cons.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="client-side-load-balancing">Client-Side Load Balancing</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With client-side load balancing, the client itself decides which server to talk to. Usually this involves the client making a request to a service registry or directory which contains the list of available servers. Then the client makes a request to one of those servers directly. The client will need to periodically poll or be pushed updates when things change.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Client-side load balancing can be very fast and efficient. Since the client is making the decision, it can choose the fastest server without any additional latency. Instead of using a full network hop to get routed to the right server on every request, we only need to (periodically) sync our list of servers with the server registry.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="example-redis-cluster">Example: Redis Cluster</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A great example of this is Redis Cluster (read more in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/deep-dives/redis" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Redis deep dive</a>). Redis cluster nodes maintain a gossip protocol between each other to share information about the cluster: which nodes are present, their status, etc. Every node knows about every other node!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In order to connect to a Redis Cluster, the client will make a request to any of the nodes in the cluster and ask about both the nodes participating in the cluster and the shards of data they contain. When it comes time to read or write data, the client hashes the key to determine which shard to send the request to, then uses the locally retrieved node information to decide which node to talk to. If you send a request to the wrong node, Redis will helpfully send you a <span class="MuiBox-root mui-1vu004u">MOVED</span> response to let you know you got the wrong node.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="example-dns">Example: DNS</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Another example of "client-side" load balancing is DNS. When you make a request to a domain name like <span class="MuiBox-root mui-1vu004u">example.com</span>, your DNS resolver will return a rotated list of IP addresses for the domain. Each new request will get a different ordering of IP addresses (or even a different set entirely).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Because each client gets a different ordering of IP addresses, they're also going to hit different servers. The DNS resolver is effectively doing client-side load balancing for us!</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This behavior of DNS is also how you avoid a single point of failure with a load balancer! You set up two load balancers (in different data centers or regions, to be safe) and use DNS to rotate between them. If one goes down, clients will automatically start trying the other one.</div></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-6">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Client-side load balancing can work great in two different scenarios: either (1) we have a small number of clients that we control, (e.g. the Redis Cluster client, or gRPC's client-side load balancing for internal services) or (2) we have a large number of clients but we can tolerate slow updates (e.g. DNS).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If we have a small number of clients that we control, getting them updates when we add or remove servers is easy! There's a lot of mechanisms to do this.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In the case of a large number of clients, the reason we care about the latency of updates is because the amount of time it takes will scale with the number of clients we have to notify. In DNS' case, entries have a TTL (time to live) which is the amount of time the entry is valid for. This allows far-flung DNS servers to cache entries for <em>their own</em> clients, but means that our updates cannot be faster than the TTL.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/d2288e511169fb20f900efcda9c3011f.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">When to Use Client-Side Load Balancing</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In an interview setting, client-side load balancing works remarkably well for internal microservices (it's actually built in to gPRC). Many interviewers actually aren't asking the details behind the lines between different services on your high-level design, but if you're asked more details about it you should definitely mention client-side load balancing!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For all other use-cases, we'll need a dedicated load balancer.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="dedicated-load-balancers">Dedicated Load Balancers</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We may not want our clients to have to refresh their list of servers or even know about the existence of multiple servers on the backend. Or we might have a large number of clients that we don't control but need to retrieve updates quickly.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In these cases, we'll use a dedicated load balancer: a server or hardware device that sits between the client and the backend servers and makes decisions about which server to send the request to.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/df1fea28849d0991053516ab44c2d909.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Dedicated Load Balancer</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">These load balancers can operate at different layers of the protocol stack and which you choose will depend, in part, on what your application needs.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Having a dedicated load balancer implies an additional hop in each request: first to the load balancer, then to the server which needs to serve the request. But in exchange we get very fast updates to our list of servers and fine-grained control over how we route requests.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="layer-4-load-balancers">Layer 4 Load Balancers</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Layer 4 load balancers operate at the transport layer (TCP/UDP). They make routing decisions based on network information like IP addresses and ports, <strong>without looking at the actual content of the packets</strong>. The effect of a L4 load balancer is as-if you randomly selected a backend server and assumed that TCP connections were established directly between the client that server.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/9b04ab2cbe0925563b575e343d8f79a1.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Simple HTTP Request with L4 Load Balancer</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Layer 4 load balancers have some key characteristics, they ...</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Maintain persistent TCP connections between client and server.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Are fast and efficient due to minimal packet inspection.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Cannot make routing decisions based on application data.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Are typically used when raw performance is the priority.</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For example, if a client establishes a TCP connection through an L4 load balancer, that same server will handle all subsequent requests within that TCP session. This makes L4 load balancers particularly well-suited for protocols that require persistent connections, like WebSocket connections. At a conceptual level, <em>it's as if we have a direct TCP connection between client and server which we can use to communicate at higher layers</em>.</div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="where-to-use-it-7">Where to Use It</h6>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">L4 load balancers are great for WebSocket connections and other protocols that <strong>require persistent connections</strong>. They're also great for high-performance applications that don't require much application-level processing.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you're using websockets in your interview, you probably want to use an L4 load balancer. For everything else, a Layer 7 load balancer is probably a better fit.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="layer-7-load-balancers">Layer 7 Load Balancers</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Layer 7 load balancers operate at the application layer, understanding protocols like HTTP. They can <strong>examine the actual content of each request and make more intelligent routing decisions</strong>.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Unlike Layer 4 load balancers, the connection-level details are not that relevant. Layer 7 load balancers receive an application-layer request (like an HTTP GET) and forward <em>that request</em> to the appropriate backend server.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/37b9eca04ceb5f48ae87cdddb5c61e13.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Simple HTTP Request with L7 Load Balancer</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Layer 7 load balancers have some key characteristics, they ...</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Terminate incoming connections and create new ones to backend servers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Can route based on request content (URL, headers, cookies, etc.).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">More CPU-intensive due to packet inspection.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Provide more flexibility and features.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Better suited for HTTP-based traffic.</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For example, an L7 load balancer could route all API requests to one set of servers while sending web page requests to another (providing similar functionality to an <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/deep-dives/api-gateway" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">API Gateway</a>), or it could ensure that all requests from a specific user go to the same server based on a cookie. The underlying TCP connection that's made to your server via an L7 load balancer is not all that relevant! It's just a way for the load balancer to forward L7 requests, like HTTP, to your server.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While L7 load balancers can help us to not have to worry about lower-level details like TCP connections, we aren't able to ignore the connection-level reality if we want persistent connections to consistent servers.</div>
<h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="where-to-use-it-8">Where to Use It</h6>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Layer 7 load balancers are great for HTTP-based traffic which is going to cover all of the protocols we've discussed so far except for Websockets.</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The choice between L4 and L7 load balancers often comes up in system design interviews when discussing real-time features. There are some L7 load balancers which explicitly support connection-oriented protocols like WebSockets, but generally speaking L4 load balancers are  better for WebSocket connections, while L7 load balancers offer more flexibility for HTTP-based solutions like long polling.</div></div></div></div></div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="health-checks-and-fault-tolerance">Health Checks and Fault Tolerance</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While load balancers play a key role in distributing load and traffic, they are also responsible for monitoring the health of backend servers. If a server loses power or crashes, the load balancer stops routing traffic to it until it recovers.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This automatic failover capability is what makes load balancers essential for high availability. They can detect and route around failures without user intervention.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">To do this, load balancers use <strong>health checks</strong>. Health checks are a way for the load balancer to determine if a server is healthy. They can be configured to check the server at different intervals and with different protocols.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Health checks can be configured to check the server at different intervals and with different protocols. A common approach is to use a TCP health check, which is a simple and efficient way to check if a server is accepting new connections. A Layer 7 health check might make an HTTP request to the server and make sure the response is success (e.g. a 200 status code vs a 500 indicating internal failures or no response indicating a crash).</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="load-balancing-algorithms">Load Balancing Algorithms</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The other benefit of a dedicated load balancer is that we have more choices over the algorithm used to distribute traffic.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Several options are available with most load balancers:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Round Robin</strong>: Requests are distributed sequentially across servers</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Random</strong>: Requests are distributed randomly across servers</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Least Connections</strong>: Requests go to the server with the fewest active connections</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Least Response Time</strong>: Requests go to the server with the fastest response time</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>IP Hash</strong>: Client IP determines which server receives the request (useful for session persistence)</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Usually, a round robin or random algorithm is appropriate, especially for stateless applications where we don't expect any particular server to be more popular than any other. When a new server is introduced to the load balancer (e.g. for scaling).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For services that require a persistent connection (e.g. those serving SSE or WebSocket connections), using Least Connections is a good idea because it avoids a situation where a single server gradually accumulates all of of the active connections.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="real-world-implementations">Real-World Implementations</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice, you'll encounter dedicated load balancers in various forms:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Hardware Load Balancers</strong>: Physical devices like F5 Networks BIG-IP</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Software Load Balancers</strong>: HAProxy, NGINX, Envoy</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Cloud Load Balancers</strong>: AWS ELB/ALB/NLB, Google Cloud Load Balancing, Azure Load Balancer</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Enterprise hardware load balancers can scale to support 100's of millions of requests per second, whereas software load balancers are more limited. Scaling load balancers is almost never part of a SWE system design interview (except for some networking specializations), but if you find the load balancer throughput is large — mentioning hardware load balancers is a good way out.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="common-deep-dives-and-challenges">Common Deep Dives and Challenges</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Ok cool, so we've got protocols, we can balance load, handle persistent connections, and maintain high availability. What else do we need to know?</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While some aspects of networking can be assumed by your interviewer, other aspects are ripe for deep dive questions and probing to check your knowledge. Beyond the core protocols and patterns, several practical networking considerations can make or break your system design.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="regionalization-and-latency">Regionalization and Latency</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For global services, you're typically going to have servers distributed across the world. A common pattern is to have multiple data centers in a single region (Amazon calls these "availability zones") so that e.g. a pipe breakage in one building doesn't take down your whole service, and then replicate this model across multiple cities spread across the world.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But while this global deployment is a great victory for humanity, it does introduce new networking challenges. The physical distance between clients and servers significantly impacts network latency. Speed of light limitations mean that a request from New York to London will always have higher latency than a request to a nearby server (&lt;1ms vs &gt;80ms).</div>
<div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Light travels through fiber optic cables at about 2/3 the speed of light in a vacuum, which is approximately 200,000 km/s. This means a round trip between New York and London (about 5,600 km) has a theoretical minimum latency of around 56ms just from the physics of signal propagation, before adding any processing time. This physical constraint is why geographic distribution is essential for low-latency applications.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">What do we do about this?</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In order to address this problem, we need to return to <strong>data locality</strong>. Across all of computing, we're going to have highest performance when the data is as close as possible to the computations we need to do.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For a regional application, we want to try to keep all of the data we need to satisfy a query (a) as close together, and (b) as close to the user as possible. If our user data is in Los Angeles, but our web servers are in New York, every database query will have tens of milliseconds of network-induced latency. And that's before we even consider the processing time of the results!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Some of this latency is <strong>unavoidable</strong>. If our users are simply far apart, there's nothing we can actually do to change that. But there are a couple of strategies we can use to optimize within the constraints of physics.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="content-delivery-networks-cdns">Content Delivery Networks (CDNs)</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The most common strategy for reducing latency is to use a <strong>Content Delivery Network (CDN)</strong>. CDNs are networks of servers that are strategically located around the world. CDNs frequently boast hundreds or even thousands of different cities where they have servers. These servers make up what is commonly referred to as an "edge location". If that edge server can answer a user's request, the user is going to get lightning fast response times — the data is just up the road!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is only possible because of <em>caching</em>. If our data doesn't change a lot, or doesn't need to be updated frequently, we can cache it at the edge server and return it from there. This is especially effective for static content like images, videos, and other assets.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In interviews, you'll see CDNs used frequently when we have data that is very cacheable and needs to be queried from across the globe. Using a CDN as a cache for e.g. <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="/learn/system-design/problem-breakdowns/fb-post-search#1-how-can-we-handle-the-large-volume-of-requests-from-users" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">search results on Facebook</a> allows us to both minimize latency <strong>and</strong> reduce the load on our backend servers.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="regional-partitioning">Regional Partitioning</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Another strategy common when we need to deal with regionalization is <strong>regional partitioning</strong>. If we have a lot of users in a single region, we can partition our data by region so that each region only has data relevant to it.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's take Uber as an example. With the Uber app we're ordering rides from drivers in a specific city. If we're in Miami, we'll never want to book a ride with a driver currently in New York. This is an important insight!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While on any given day we may have millions of riders and drivers, inside one particular city we may only have a few thousand. Our physical architecture and network topology can mirror this!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can bundle together nearby cities into a single local region (e.g. "Northeast US", or "Southwest US"). Each region can have its own database hosted on distinct servers located in that geography (maybe we put our data centers in New York and Los Angeles). The servers handling requests can be co-located alongside the databases they need to query. Then when users want to book a ride, or look up their status, their queries can be answered by their regional services (fast), and those regional services can use a local database to process the query (very fast). Nice and optimal!</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="handling-failures-and-fault-modes">Handling Failures and Fault Modes</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Beyond regionalization, another deep dive question that comes up frequently is how we handle failures in our system. Part of this is server failures: servers crash, solar flares can flip bits, power can be cut. But we may also deal with network failures! Cables get cut, routers fail, and packets get dropped. Robust system design requires planning for these failures.</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The fallacy of "the network is reliable" is one of the most dangerous assumptions in distributed systems. Always design with the expectation that network calls will fail, be delayed, or return unexpected results.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Addressing these failures common to many deep-dives and there are several strategies we can use to address them.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="timeouts-and-retries-with-backoff">Timeouts and Retries with Backoff</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The most elementary hygiene for handling failures is to use timeouts and retries. If we expect a request to take a certain amount of time, we can set a timeout and if the request takes too long we can give up and try again.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Retrying requests is a great strategy for dealing with transient failures. If a server is temporarily slow, we can retry the request and it will likely succeed. Having <strong>idempotent APIs</strong> is key here because we can retry the same request multiple times without causing issues.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="backoff">Backoff</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Retries can be a double-edged sword, though. If we have a lot of retries, we may be retrying requests that are going to fail over and over again. This can actually make the problem worse!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is why most retry strategies also include a <strong>backoff</strong> strategy. Instead of retrying immediately, we wait a short amount of time before retrying. If the request still fails, we wait a little longer. This gives the system time to recover and reduces the load on the system.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">It's important there is some randomness to the backoff strategy (often called "jitter"). It doesn't help us to have all of our clients retry at the same time! The worst case would be having all our failing requests synchronize and retry at the same time over and over again like a jackhammer. No good.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In system design interviews, <strong>interviewers are often looking for the magic phrase "retry with exponential backoff"</strong>. In more senior interviews, you may be asked to elaborate about adding jitter.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">AWS has a great blog post on the <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter/" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">timeouts, retries, and backoff</a> if you want to learn more.</div>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="idempotency">Idempotency</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Retries are cool except when they have side effects. Imagine a payment system where we're trying to charge a user $10 for something. If we retry the same request multiple times, we're going to charge the user $20 (or $2,000) instead of $10! Ouch.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is why we need to make sure our APIs are <strong>idempotent</strong>. Idempotent APIs are APIs that can be called multiple times and they produce the same result every time. HTTP GET requests are common examples of idempotent APIs. While the content returned by a GET request may change, the act of fetching the content does not change the state of the system.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">But reading data is easy, how about writing data? For these cases, it's common for us to introduce an <strong>idempotency key</strong> to our API. The idempotency key is a unique identifier for a request that we can use to make sure the same request is idempotent.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For our payment example, if we know a user is only ever going to buy one item per day, we can set an idempotency to the user's ID and the current date. On the server-side, we can check to see if we've already processed (or are currently processing) a request with that idempotency key and process it only once. User-friendly APIs will wait for the request to complete then send the results to all requesters. Less friendly APIs will just return an error saying the request already exists. But both will keep you from double charging your user's credit cards.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="circuit-breakers">Circuit Breakers</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The last topic we see commonly in deep dives is how to handle <strong>cascading failures</strong> in a system. Senior candidates are frequently asked questions like “what happens when this service goes down”. Sometimes the answer is simple: “we fail and retry until it boots back up” — but occasionally that will introduce new problems for the system!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If your database has gone down cold and you need to boot it up one instance at a time, having a firehose of retries and angry users might pin down an instance from ever getting started (sometimes ominously referred to as a "thundering herd"). You can't get the first instance up, so you have no hope of getting the whole database back online. You’re stuck!</div>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Experienced engineers who have spent time oncall will have a lot of war stories about cascading failures. It's a common problem that usually goes unnoticed until it bites you at 3am.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">As such, it makes for a great interview question! Not only does it help you to find candidates who understand how to prevent some of the most pernicious issues, but it's also a decent screen for experience which many interviewers are looking for.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The key for your preparation is to familiarize yourself with scenarios where one failure might create new failures: a cascade of failures. Being able to identify these patterns and how to mitigate them is a great way to stand out in an interview.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Enter circuit breakers: a crucial pattern for robust system design that directly impacts network communication. Circuit breakers protect your system when network calls to dependencies fail repeatedly. Here's how they work:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The circuit breaker monitors for failures when calling external services</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">When failures exceed a threshold, the circuit "trips" to an open state</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">While open, requests immediately fail without attempting the actual call</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">After a timeout period, the circuit transitions to a "half-open" state</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">A test request determines whether to close the circuit or keep it open</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This pattern, inspired by electrical circuit breakers, prevents cascading failures across distributed systems and gives failing services time to recover.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Circuit breakers provide numerous advantages:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Fail Fast: Quickly reject requests to failing services instead of waiting for timeouts</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Reduce Load: Prevent overwhelming already struggling services with more requests</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Self-Healing: Automatically test recovery without full traffic load</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Improved User Experience: Provide fast fallbacks instead of hanging UI</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">System Stability: Prevent failures in one service from affecting the entire system</div></li>
</ul>
<h5 class="MuiTypography-root MuiTypography-h6 mui-13de2kc" id="where-to-use-it-9">Where to Use It</h5>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Circuit breakers can be a great response when an interviewer is deep-diving on reliability, failure modes, or disaster recovery. Being able to mention circuit breakers and apply them in useful places is a great way to show off knowledge that otherwise is won at 3:00am battling a hardware failure when the system Just. Won’t. Come. Back. Up.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Some example sites to apply circuit breakers:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">External API calls to third-party services</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Database connections and queries</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Service-to-service communication in microservices</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Resource-intensive operations that might time out</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Any network call that could fail or become slow</div></li>
</ul>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="wrapping-up">Wrapping Up</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Woo. That was a lot. Networking is the foundation that connects all components in a distributed system. While the field is vast, focusing on these key areas will prepare you for most system design interviews:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Understand the basics</strong>: IP addressing, DNS, and the TCP/IP model</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Know your protocols</strong>: TCP vs. UDP, HTTP/HTTPS, WebSockets, and gRPC</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Master load balancing</strong>: Client-side load balancing and dedicated load balancers</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Plan for practical realities</strong>: Regionalization and patterns for handling failures</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Remember that networking decisions impact every aspect of your system - from latency and throughput to reliability and security. By making informed choices about networking components and patterns, you'll design systems that are not just functional, but robust and scalable.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In your interviews, be prepared to justify your networking choices based on the specific requirements of the system you're designing. We've outlined a bunch of sensible defaults, but the reality for most problems is there's no single right answer and your interviewer wants to see how you think through tradeoffs.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="follow-up-opportunities">Follow-Up Opportunities</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Learning by reading or watching is sometimes not the best way for builders to integrate new knowledge. One of the easiest ways to learn about networking is to create some network traffic and watch it flow through the network yourself. Download <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.wireshark.org/" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Wireshark</a> and try to capture some network traffic on your own machine. This will give you a good idea of the entire protocol stack in action!</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">After you've done that, try simulating some common networking failures. Mac's Network Link Conditioner (available through XCode) is a great tool that allows you to simulate what happens when there is latency in the network or packet loss. Try simulating a really nasty cell-phone connection and see how websites and apps respond. You'll often find some surprises (and a lot of bugs). Have fun!</div></div>