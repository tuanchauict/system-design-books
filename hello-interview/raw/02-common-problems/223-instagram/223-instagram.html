<div id="markdown" class="mui-46nw7a"><div><div class="flex flex-col gap-2 md:gap-4"><div class="flex flex-col"><h6 class="MuiTypography-root MuiTypography-h6 mui-zfm63x">Question Breakdowns</h6><h1 class="MuiTypography-root MuiTypography-h2 mui-161snwm">Design Instagram</h1></div><div class="flex flex-col md:flex-row gap-2 md:items-center justify-between"><div class="flex flex-col lg:flex-row gap-4 md:items-center"><a target="_blank" rel="noopener noreferrer" class="flex flex-row gap-2 items-center" href="https://www.linkedin.com/in/evan-king-40072280/" style="text-decoration: none;"><img alt="Evan King" loading="lazy" width="40" height="40" decoding="async" data-nimg="1" class="rounded-full" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fevan-headshot.36cce7dc.png&amp;w=48&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fevan-headshot.36cce7dc.png&amp;w=96&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fevan-headshot.36cce7dc.png&amp;w=96&amp;q=75" style="color: transparent;"><div class="flex flex-col"><div class="flex flex-row gap-2 items-center"><p class="MuiTypography-root MuiTypography-body2 mui-ltrqv0">Evan King</p><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeInherit mui-70s7oy" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LinkedInIcon"><path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77z"></path></svg></div><span class="MuiTypography-root MuiTypography-caption mui-1eozzb8">Ex-Meta Staff Engineer</span></div></a><div class="flex flex-row gap-4 md:gap-8 items-center"><div class="flex flex-row gap-1 items-center" aria-label="Difficulty"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-5 h-5 text-gray-500"><path stroke-linecap="round" stroke-linejoin="round" d="M15.362 5.214A8.252 8.252 0 0 1 12 21 8.25 8.25 0 0 1 6.038 7.047 8.287 8.287 0 0 0 9 9.601a8.983 8.983 0 0 1 3.361-6.867 8.21 8.21 0 0 0 3 2.48Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M12 18a3.75 3.75 0 0 0 .495-7.468 5.99 5.99 0 0 0-1.925 3.547 5.975 5.975 0 0 1-2.133-1.001A3.75 3.75 0 0 0 12 18Z"></path></svg><p class="MuiTypography-root MuiTypography-body2 mui-su24yt">medium</p></div><div class="flex flex-row gap-1 items-center" aria-label="Average time allowed in interview"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-5 h-5 text-gray-500"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg><p class="MuiTypography-root MuiTypography-body2 mui-1pb8xyp">35 min</p></div></div></div><a class="MuiButtonBase-root MuiButton-root MuiButton-contained MuiButton-containedPrimary MuiButton-sizeSmall MuiButton-containedSizeSmall MuiButton-colorPrimary MuiButton-disableElevation MuiButton-root MuiButton-contained MuiButton-containedPrimary MuiButton-sizeSmall MuiButton-containedSizeSmall MuiButton-colorPrimary MuiButton-disableElevation mui-1c7cv5a" tabindex="0" href="/practice/system-design/start/instagram" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.672 13.684 16.6m0 0-2.51 2.225.569-9.47 5.227 7.917-3.286-.672ZM12 2.25V4.5m5.834.166-1.591 1.591M20.25 10.5H18M7.757 14.743l-1.59 1.59M6 10.5H3.75m4.007-4.243-1.59-1.59"></path></svg>Practice this problem<span class="MuiTouchRipple-root mui-w0pj6f"></span></a></div></div><hr class="MuiDivider-root MuiDivider-fullWidth mui-1rvhejo"></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="understanding-the-problem">Understanding the Problem</h2>
<div class="my-6"><div class="MuiBox-root mui-n2cj60"><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>üì∏ What is <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.instagram.com/" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Instagram</a>?</strong>
Instagram is a social media platform primarily focused on visual content, allowing users to share photos and videos with their followers.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Designing Instagram is one of the most common system design interview questions asked not just at Meta, but across all FAANG and FAANG-adjacent companies. It has a lot of similarities with our breakdowns of <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/fb-news-feed" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">FB News Feed</a> and <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/dropbox" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Dropbox</a>, but given the popularity and demand, we decided this warranted its own breakdown.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="functional-requirements"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#1-functional-requirements" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Functional Requirements</a></h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>Core Requirements</strong></div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to create posts featuring photos, videos, and a simple caption.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to follow other users.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to see a chronological feed of posts from the users they follow.</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>Below the line (out of scope):</strong></div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to like and comment on posts.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to search for users, hashtags, or locations.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to create and view stories (ephemeral content).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Users should be able to go live (real-time video streaming).</div></li>
</ul>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="non-functional-requirements"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#2-non-functional-requirements" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Non-Functional Requirements</a></h3>
<div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">If you're someone who often struggles to come up with your non-functional requirements, take a look at this list of <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#2-non-functional-requirements" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">common non-functional requirements</a> that should be considered. Just remember, most systems are all these things (fault tolerant, scalable, etc) but your goal is to identify the unique characteristics that make this system challenging or unique.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Before defining your non-functional requirements in an interview, it's wise to inquire about the scale of the system as this will have a meaningful impact on your design. In this case, we'll be looking at a system with 500M DAU with 100M posts per day.</div>
<div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>Core Requirements</strong></div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should be <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/deep-dives/cap-theorem" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">highly available</a>, prioritizing availability of photos/videos over consistency (eventual consistency is fine, up to 2 minutes).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should deliver feed content with low latency (&lt; 500ms end-to-end response time for feed requests).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should render photos and videos instantly (low latency media delivery).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should be scalable to support 500M DAU.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>Below the line (out of scope):</strong></div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should be secure and protect user data (authentication, authorization, encryption).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should be fault-tolerant and highly reliable (no data loss).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The system should provide analytics on user behavior and engagement.</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it might look on your whiteboard:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/a34845e8f75d4ad1fa82e65e5f10f1c9.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">IG Requirements</span></div></div></div></div><div class="mt-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Adding features that are out of scope is a "nice to have". It shows product thinking and gives your interviewer a chance to help you reprioritize based on what they want to see in the interview. That said, it's very much a nice to have. If additional features are not coming to you quickly, don't waste your time and move on.</div></div></div></div></div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="the-set-up">The Set Up</h2><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="defining-the-core-entities"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#core-entities-2-minutes" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Defining the Core Entities</a></h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's start by identifying the core entities we'll need. I prefer to begin with a high-level overview before diving into specifics - this helps establish the foundation we'll build upon. That said, if you're someone who finds value in outlining the complete schema upfront with all columns and relationships defined, that's perfectly fine too! There's no single "right" approach - do what works best for you. The key is to have a clear understanding of the main building blocks we'll need.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">To satisfy our key functional requirements, we'll need the following entities:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>User:</strong> This entity will store user information like username, profile details, etc.  (We'll keep it minimal for now).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Post:</strong> This will include a reference to the media file, a caption, and the user who created it. Crucially, a single Post entity will handle BOTH photos and videos.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Media:</strong> Represents the actual bytes of the media file. We'll use S3 for this.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Follow:</strong> Represents the relationship between two users, where one user (the follower) is following another user (the followee). This captures the uni-directional "follow" relationship.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In the actual interview, this can be as simple as a short list like this. Just make sure you talk through the entities with your interviewer to ensure you are on the same page.</div><div class="max-w-[200px]"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/3b175036bf4fc0d5edc50be3c74c72db.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">IG Entities</span></div></div></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="api-or-system-interface"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#api-or-system-interface-5-minutes" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">API or System Interface</a></h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The API is the main way users will interact with Instagram. Defining it early helps us structure the rest of our design. We'll start simple and, as always, we can add more detail as we go. I'll just create one endpoint for each of our core requirements.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">First, users need to create posts. We'll use a <span class="MuiBox-root mui-1vu004u">POST</span> request for that:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>POST /posts -&gt; postId
</span>{
  "media": {photo or video bytes},
  "caption": "My cool photo!",
}</code></div></div></pre><div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We're going to handle the actual upload of the photo or video separately, using a pre-signed URL. I'll get into the details of why we do that later, when we talk about handling large files. For now, I'm just focusing on the basic API to create the post metadata. We can assume the client gets a postId back, which it'll use later.</div></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Next, users need to follow other users. We'll model this as a relationship resource:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>POST /follows
</span>{
  "followedId": "123"
}</code></div></div></pre><div class="my-6"><div class="MuiBox-root mui-zfu8o1"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The follower's ID will be extracted from the authentication token (JWT or session), so we don't need to specify it in the request body. This is both more secure and follows the principle of least privilege. In practice, it's fine to include here, you'll just need to compare it to the session before following.</div></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Finally, users need to see their feed. This is a GET request:</div><pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>GET /feed?cursor={cursor}&amp;limit={page_size} -&gt; Post[]</span></code></div></div></pre><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We'll use a <span class="MuiBox-root mui-1vu004u">cursor</span> for pagination, and a <span class="MuiBox-root mui-1vu004u">limit</span> to control the page size.  I'm keeping the details of the posts array vague for now ‚Äì we can fill that in later. The important thing is that we return an array of posts, and a <span class="MuiBox-root mui-1vu004u">next_cursor</span> for getting the next page.</div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="high-level-design"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#high-level-design-10-15-minutes" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">High-Level Design</a></h2><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For our high-level design, we're simply going to work one-by-one through our functional requirements.</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="1-users-should-be-able-to-create-posts-featuring-photos-videos-and-a-simple-caption">1) Users should be able to create posts featuring photos, videos, and a simple caption</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When a user is active on instagram, they should see a big button somewhere to create a post. Clicking it will take them to a new page or modal that asks for the media they want to upload and a caption which will trigger our <span class="MuiBox-root mui-1vu004u">POST /posts</span> endpoint.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can lay out the core components necessary to handle this request while making the initial assumption that our media is small enough to be uploaded directly via a single request.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/ae3d18beaa6733f7c37af45ce342f659.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Create Post</span></div></div></div></div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Clients:</strong> Users will interact with the system through the clients website or app. All client requests will be routed to the system's backend through an API Gateway.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>API Gateway:</strong> This serves as an entry point for clients to access the different microservices of the system. It's primarily responsible for routing requests to the appropriate services but can also be configured to handle cross-cutting concerns like authentication, rate limiting, and logging.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Post Service:</strong> Our first microservice is responsible for handling post creation requests. It will receive the media and caption, store the post metadata in the database, the  actual bytes on the media in a blob store, and return a <span class="MuiBox-root mui-1vu004u">postId</span> to the client.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Posts DB:</strong> Stores metadata about each post including who created it, when it was created, the caption, and a link to the media in the blob store.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Blob Store:</strong> Stores the actual bytes of the media. We'll use S3 in our case as it's the most popular solution.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Quickly, let's go over what happens when a user uploads a post.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The client makes a POST request to the API Gateway with the media and caption.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The API Gateway routes the request to the Post Service.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The Post Service receives the media and caption, stores the post metadata in the database, and the actual bytes on the media in a blob store.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The Post Service returns a <span class="MuiBox-root mui-1vu004u">postId</span> to the client.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Easy enough!</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="2-users-should-be-able-to-follow-other-users">2) Users should be able to follow other users</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Instagram is social! In order to see the posts of the people we follow, we need to be able to follow other users in the first place.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Importantly, this is a unidirectional relationship. For example, I follow @leomessi, but he (sadly) doesn't follow me back. Thus, I'll see his posts in my feed, but he won't see mine.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can model this relationship with just a Followers table in our database that stores the <span class="MuiBox-root mui-1vu004u">followerId</span> and <span class="MuiBox-root mui-1vu004u">followedId</span>. Each time we receive a new <span class="MuiBox-root mui-1vu004u">POST /follows</span> request, we'll insert a single new row into our table.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/bb801e7222f4d3f24cebcbf329a18a63.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Followers</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We've added a dedicated Follow Service to handle follow/unfollow operations separately from the Post Service. Since following users happens less frequently than posting and viewing content, this separation lets us optimize and scale each service based on its specific needs.</div><div class="my-6"><div class="MuiBox-root mui-1qwve7o"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We get a lot of comments about people concerned about two services writing to the same database. While some claim that each service should own its data exclusively, this is arguably more academic than practical. Many production systems at FAANG and other large tech companies do have multiple services writing to the same database.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The tradeoffs are worth understanding:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Separate databases per service:
‚úÖ Stronger encapsulation and isolation
‚úÖ Independent scaling of database resources
‚úÖ Freedom to choose different database technologies per service
‚ùå Requires distributed transactions or eventual consistency for cross-service operations
‚ùå Increases operational complexity (more databases to maintain)
‚ùå Potentially higher infrastructure costs</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Shared database:
‚úÖ Simpler transactions across domain boundaries
‚úÖ Easier to maintain referential integrity
‚úÖ Often simpler operationally and developmentally
‚ùå Tighter coupling between services
‚ùå Risk of one service's queries affecting another's performance
‚ùå Schema changes require more coordination</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">In practice, many organizations start with shared databases and evolve toward more isolated data stores as specific needs arise. For our Instagram design, having both the Post Service and Follow Service access the same database is a perfectly valid approach, especially since they're dealing with related domain concepts and the coupling between them is natural.</div></div><div class="MuiBox-root mui-iqoxai"></div><button class="MuiButtonBase-root MuiButton-root MuiButton-text MuiButton-textInfo MuiButton-sizeSmall MuiButton-textSizeSmall MuiButton-colorInfo MuiButton-disableElevation MuiButton-root MuiButton-text MuiButton-textInfo MuiButton-sizeSmall MuiButton-textSizeSmall MuiButton-colorInfo MuiButton-disableElevation mui-cmu0xt" tabindex="0" type="button">Show More<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-4 w-4"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="3-users-should-be-able-to-see-a-chronological-feed-of-posts-from-the-users-they-follow">3) Users should be able to see a chronological feed of posts from the users they follow</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Last up from our core functional requirements is the need to view a chronological feed of posts from the users we follow. Let's start with the simplest approach, and then we'll identify its limitations and improve it in our deep dives. Initially, we could:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Get followees: Query the <span class="MuiBox-root mui-1vu004u">Follow</span> table to get a list of <span class="MuiBox-root mui-1vu004u">user_id</span>s that the current user follows.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Get Posts: For <em>each</em> of those followed users, query the <span class="MuiBox-root mui-1vu004u">Post</span> table to get their recent posts.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Merge and Sort: Combine all the retrieved posts and sort them chronologically (by timestamp or <span class="MuiBox-root mui-1vu004u">postId</span>).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Return: Return the sorted posts to the client.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">I'm going to opt to have the feed service handle this for now rather than creating a new service, but there is no right or wrong answer. You're trading off between the complexity of the system and the cost of the operations.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Note that these queries would be incredibly slow if we needed to look through every single Followers row for every user and then search through every Post row to find the ones we want. To avoid these full table scans, we can add a few <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/deep-dives/db-indexing" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">indexes to our database</a>.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Since we're about to discuss indexing, it's an appropriate time to also choose a database technology. Given the scale, limited number of relationships, and the fact that eventual consistency is acceptable, I'm going to go with <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/deep-dives/db-dynamodb" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">DynamoDB</a>. That said, <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/deep-dives/db-postgres" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">PostgreSQL</a> or most other databases would be equally valid choices, you'll just want to be able to justify your decision.</div><div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Fun fact: Instagram uses PostgreSQL as its main Post metadata database. This is interesting because if you were following the SQL vs NoSQL debates of yesteryear you may be convinced that a SQL DB could not scale to support our 500M DAU. Clearly not the case!</div></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Back to indexing, given we're opting for DynamoDB, we'll need to add a few indexes to our tables to avoid full table scans. For the Follower table, we'll make the partition key the <span class="MuiBox-root mui-1vu004u">followerId</span> and the sort key the <span class="MuiBox-root mui-1vu004u">followedId</span>. This way, we can query for all the followers of a given user efficiently and the combination of the partition key and the sort key will give us a unique identifier for each follow.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For the Post table, we'll make the partition key the <span class="MuiBox-root mui-1vu004u">userId</span> since most of our queries will be to get the posts of a given user. We can make the sort key the <span class="MuiBox-root mui-1vu004u">postId</span>. By making the <span class="MuiBox-root mui-1vu004u">postId</span> a monotonically increasing id like a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://github.com/paralleldrive/cuid2" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">cuid</a>, we will be able to use it to sort the posts in chronological order efficiently.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/b5386757662dfdf4e8b909e6b4c6a21a.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Feed Generation</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So here is what happens with our simple approach.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The client makes a GET request to the API Gateway with the <span class="MuiBox-root mui-1vu004u">cursor</span> and <span class="MuiBox-root mui-1vu004u">limit</span>.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The API Gateway routes the request to the Post Service.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The Post Service queries the <span class="MuiBox-root mui-1vu004u">Follow</span> table to get the followed users of the current user.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The Post Service queries the <span class="MuiBox-root mui-1vu004u">Post</span> table for each followed user to get their recent posts.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The Post Service combines and sorts the posts and returns them to the client, limited by the <span class="MuiBox-root mui-1vu004u">cursor</span> and <span class="MuiBox-root mui-1vu004u">limit</span>.</div></li>
</ol><div class="my-6"><div class="MuiBox-root mui-1cdyrx9"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">You're probably thinking, "wait a minute, what if I'm following thousands of people? This will be crazy slow, even with indexes, right?" And you're right! This is exactly the kind of problem we'll solve in our deep dives.</div></div></div></div></div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="potential-deep-dives"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#deep-dives-10-minutes" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Potential Deep Dives</a></h2><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At this point, we have a basic, functioning system that satisfies the core functional requirements of Instagram - users can upload photos/videos, follow other users, and view a chronological feed. However, our current design has significant limitations, particularly around feed generation performance and media delivery at scale. Let's look back at our non-functional requirements and explore how we can improve our system to handle 500M DAU with low latency and global distribution.</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="1-the-system-should-deliver-feed-content-with-low-latency--500ms-">1) The system should deliver feed content with low latency (&lt; 500ms )</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We'll start our deep dives right where we left off with our high-level design -- feed generation. Our current "fan-out on read" approach could work for a small app, but it's not going to scale to 500M DAU.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's first understand why in the context of the database we chose.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Our first concern would be that for users following 1,000+ accounts, we need 1,000+ queries to the Posts table to get posts from each of their followed accounts.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">DynamoDB does offer batch operations, but each batch is limited to 100 items and 16MB of data. For a user following 1,000 accounts, we'd need at least 10 separate batch operations to query recent posts. While these can operate in parallel, it still creates several major problems.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Read Amplification: Every time a user refreshes their feed, we generate a large number of database reads. With 500M daily active users refreshing their feeds multiple times per day, this quickly becomes unsustainable. This is going to get expensive fast.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Repeated Work: If two users follow many of the same accounts (which is common), we're repeatedly querying for the same posts. At Instagram's scale, popular posts might be retrieved millions of times.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Unpredictable Performance: The latency of a feed request would vary dramatically based on how many accounts a user follows and how active those accounts are. This makes consistent performance nearly impossible.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's put this in perspective with some numbers:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Each feed refresh might need to process 10,000 posts (1,000 followed accounts √ó 10 posts/day)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">With 500M DAU, if each user refreshes their feed 5 times daily, that's 2.5 billion feed generations per day</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">During peak usage (e.g., evenings, major events), we might see 150,000+ feed requests per second</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">With these numbers, it's evident that even with a well-architected DynamoDB implementation, we'd struggle to maintain our 500ms latency target. We'd either:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Need to massively overprovision our database capacity, making the system prohibitively expensive, or</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Accept higher latencies during peak usage, violating our requirements</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This inefficiency is inherent to the fan-out on read model. The core issue is that we're postponing the computational work until read time, which is precisely when users expect immediate results.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's analyze some alternatives.</div><div class="my-6 flex flex-col gap-4"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-ifi55z"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-1ev8i4f" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Bad Solution: Simple Caching (Improvement on Fan-out on Read)</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The most obvious improvement to the fan-out on read approach is adding a cache in front of the <span class="MuiBox-root mui-1vu004u">Posts</span> table to cache each users recent posts. We can use Redis for this. The idea is simple: before querying the database for a user's followed users' posts, we check the cache. If the posts are in the cache, we return them. If not, we query the database and then store the results in the cache for future requests.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can key the cache by a combination of the <span class="MuiBox-root mui-1vu004u">user_id</span> and a <span class="MuiBox-root mui-1vu004u">cursor</span> (or timestamp). This lets us get a specific "page" of the feed from the cache. An example key would be: <span class="MuiBox-root mui-1vu004u">feed:{user_id}:{cursor}</span>. The value would be a list of <span class="MuiBox-root mui-1vu004u">postId</span>s.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/261dc45c273144fbabe91aa9c6ad5d7d.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Feed Generation with Simple Cache</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Caching helps but doesn't fundamentally solve our scalability challenges. The cache needs to be massive to achieve a meaningful hit rate at Instagram's scale, and we still perform expensive fan-out reads to aggregate posts from all followed users for every feed request. While caching is a useful optimization, it's treating the symptom rather than addressing the root problem of our fan-out read architecture.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-nhbct3"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-guv1gb" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Good Solution: Precompute Feeds (Fan-out on Write)</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-1">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A much better approach is to precompute the feeds. Instead of generating the feed when the user requests it (fan-out on read), we generate it when a user posts (fan-out on write).</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it works: When a user creates a new post, we query the <span class="MuiBox-root mui-1vu004u">Follows</span> table to get all users who follow the posting user. For each follower, we prepend the new <span class="MuiBox-root mui-1vu004u">postId</span> to their precomputed feed. This precomputed feed can be stored in a dedicated <span class="MuiBox-root mui-1vu004u">Feeds</span> table (in DynamoDB, for example) or in a cache like Redis.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's use Redis. It provides very fast read and write access, perfect for feeds. We can store each user's feed as a sorted set (ZSET in Redis). The members are <span class="MuiBox-root mui-1vu004u">postId</span>s, and the scores are timestamps (or <span class="MuiBox-root mui-1vu004u">postId</span>s, if they are chronologically sortable).</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/b889f2d8dd041cf30eeed9e5118d2ecc.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Precomputed Feeds</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><strong>Data Model (Redis):</strong></div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Key: <span class="MuiBox-root mui-1vu004u">feed:{user_id}</span></div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Type: Sorted Set (ZSET)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Members: <span class="MuiBox-root mui-1vu004u">postId</span></div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Scores: <span class="MuiBox-root mui-1vu004u">timestamp</span> (or <span class="MuiBox-root mui-1vu004u">postId</span>)</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When a user requests their feed, we read the top N posts from their sorted set in Redis, which is a single, fast operation. However, we still need to hydrate the posts based on these <span class="MuiBox-root mui-1vu004u">postId</span>s. To do this we have 3 options:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">For each postId in the cache, go fetch the metadata from the <span class="MuiBox-root mui-1vu004u">Posts</span> table in DynamoDB. This is simple but requires an additional database query for every feed request.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Rather than caching the postId, we could cache the entire post metadata in Redis. This way we don't have to make a second query to the <span class="MuiBox-root mui-1vu004u">Posts</span> table to get the post metadata. This is faster but uses more memory and introduces data consistency challenges.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Use a hybrid approach with two Redis data structures: one for the feed's postIds (ZSET) and another for a short-lived post metadata cache (HASH). When we need to hydrate posts:
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">First, try to get all post metadata from the Redis post cache</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">For any cache misses, batch fetch from DynamoDB using BatchGetItem</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Update the Redis post cache with the fetched metadata</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Return the combined results</div></li>
</ul>
</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The hybrid approach (option 3) gives us the best balance of performance and resource usage. We can tune the TTL of the post metadata cache based on our memory constraints and consistency requirements. For example, if a post were to get updated, like a change to the caption, we would just invalidate the cache for that post and it would be updated in the next feed request.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">To recap, here is what happens when a new post is created.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We store the post metadata in the <span class="MuiBox-root mui-1vu004u">Posts</span> table and the media in the blob store like before.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We put the postId onto a queue to be asynchronously processed by the Feed Fan-out service.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The feed fan-out service will query the <span class="MuiBox-root mui-1vu004u">Follows</span> table to get all users who follow the posting user.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">For each follower, it will prepend the new <span class="MuiBox-root mui-1vu004u">postId</span> to their precomputed feed.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The feed fan-out service will store the new feed in Redis.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Then, when a user requests their feed, we:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Read the top N posts from their sorted set in Redis.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Hydrate the posts based on these <span class="MuiBox-root mui-1vu004u">postId</span>s. We first check if the post metadata is in the Redis post cache. If it is, we use that. If it's not, we batch fetch from DynamoDB using BatchGetItem.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Combine the results and return them to the user.</div></li>
</ol><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-1">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This 'fan-out on write' approach significantly improves read performance, making feed retrieval a fast, single Redis query (plus metadata lookups). However, we've traded read-time complexity for write-time complexity and increased storage. The primary challenge is write amplification, especially the 'celebrity problem'. A single post by a user with millions of followers triggers millions of writes to Redis, potentially overwhelming our system and increasing write latency for popular users. This is because we need to update the feed cache for the millions of people following them.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-11r69q9"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-3ujfba" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Great Solution: Hybrid Approach (Precompute + Real-time)</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-2">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can address the main limitation of the precompute approach, that celebrities will result in massive write amplification, by using a hybrid approach. We combine fanout-on-write for most users with fanout-on-read for popular accounts. This provides a good balance: fast reads for most users and manageable write amplification.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Here's how it works: We define a threshold for the number of followers. Let's say, 100,000 followers. For users with fewer than 100,000 followers, we precompute their followers' feeds just like in the "good" approach above. For users with more than 100,000 followers (the "celebrities"), we DON'T precompute their posts into their followers' feeds.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Instead:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">When a "celebrity" posts, we add the post to the <span class="MuiBox-root mui-1vu004u">Posts</span> table and do not trigger an asynchronous feed update for their followers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">When a user requests their feed: We fetch the precomputed portion of their feed from Redis (posts from users with &lt; 100,000 followers). Then, we also query the <span class="MuiBox-root mui-1vu004u">Posts</span> table for recent posts from the "celebrities" they follow. We then merge the precomputed feed with the recent posts from celebrities, chronologically and return the merged feed.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Thus, we end up with an effective mix between pre-computation and real-time merging.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Fanout-on-write for the majority of users (follower count &lt; 100,000)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Fanout-on-read for the few "celebrity" users (follower count &gt; 100,000)</div></li>
</ol><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-2">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">As is always the case, more complexity comes with its own tradeoffs. The 100,000 follower threshold needs to be carefully tuned - set it too low and we don't solve the write amplification problem, set it too high and we impact read performance for too many users.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Users following many celebrities will experience slower feed loads than those who don't, creating an inconsistent user experience. We'll need to set clear SLAs for different user segments and potentially implement additional caching specifically for celebrity posts. We also introduce storage complexity by maintaining two separate systems - the precomputed feeds in Redis for regular users and the real-time query system for celebrity posts. This increases operational complexity and requires careful monitoring of both systems.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Despite these challenges, this hybrid approach has proven effective in practice. Instagram actually uses a similar approach in production, demonstrating that the benefits outweigh the added complexity.</div></div></div></div></div></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="2-the-system-should-render-photos-and-videos-instantly-supporting-photos-up-to-8mb-and-videos-up-to-4gb">2) The system should render photos and videos instantly, supporting photos up to 8mb and videos up to 4GB</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There are two key challenges to large media files.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Upload efficiency.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Download/viewing latency.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Lets take these one at a time.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">First, as we discuss in both <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/dropbox" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">DropBox</a> and <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/youtube" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">YouTube</a>, uploading large media files requires chunking. This is because a single HTTP request is usually constrained to a max payload size &lt; 2GB. Thus, in order to upload a 4GB video, we would need to send at least 2 (in practice, more given metadata) requests.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A common solution is to use AWS S3's multipart upload API. At a high-level, here is how it works:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">First, we will call <span class="MuiBox-root mui-1vu004u">POST /posts</span> to create the post metadata and get a <span class="MuiBox-root mui-1vu004u">postId</span> as before, but now it will also return a pre-signed URL that can be used to upload the media. This URL is valid for a limited time (e.g., 1 hour) and allows the user to upload directly to S3 without having to go through our servers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Client side, we use the multipart upload API to upload the file in chunks to the pre-signed URL.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">S3 will automatically handle reassembling the chunks and store the final file in S3.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When we initially uploaded the post metadata, we would include a media upload status field originally set to <span class="MuiBox-root mui-1vu004u">pending</span>. Once the media is uploaded, we update the post metadata with the S3 <span class="MuiBox-root mui-1vu004u">object_key</span> and update the media upload status to <span class="MuiBox-root mui-1vu004u">complete</span>.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">There are two main ways to handle the post metadata update after upload completion:</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Client-driven approach: The client sends a PATCH request to update the post metadata with the S3 <span class="MuiBox-root mui-1vu004u">object_key</span> and sets the media upload status to <span class="MuiBox-root mui-1vu004u">complete</span> once the multipart upload finishes.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Server-driven approach: We configure S3 event notifications to trigger a Lambda function or background job when the multipart upload completes. This job then updates the post metadata automatically.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The client-driven approach (Option 1) is simpler to implement but less reliable since we have to trust clients to properly report upload completion. The server-driven approach (Option 2) is more complex but provides better data consistency guarantees since our backend maintains full control over the metadata updates. Most production systems opt for Option 2 despite the added complexity.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/43d85e347627b68a4d424307fa63a23e.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Upload</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Now that we have all our media uploaded and in S3, let's talk about how we get it to render quickly when a user views it.</div><div class="my-6 flex flex-col gap-4"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-ifi55z"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-1ev8i4f" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Bad Solution: Direct S3 Serving</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-3">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The simplest approach would be to serve media directly from S3. When a user views a post, we return the S3 URL for the media file, and their client downloads it directly from S3. This is straightforward to implement and works fine for small applications, but it doesn't scale well for a global application like Instagram.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/20f8e7ba1317c7a9b928678e0b3ece13.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Direct S3 Serving</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-3">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This approach falls short in several ways. First, users far from our S3 bucket's region will experience high latency when loading media. A user in Singapore accessing media stored in us-east-1 might wait seconds for images to load. Second, every request hits S3 directly, which becomes expensive at scale and doesn't take advantage of any caching. Finally, we're serving the same high-resolution files to all users regardless of their device or network conditions, wasting bandwidth and slowing down the user experience.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-nhbct3"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-guv1gb" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Good Solution: Global CDN Distribution</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-4">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">A significant improvement is to put a CDN like CloudFront in front of our S3 bucket. The CDN maintains a global network of edge locations that cache our media files closer to users. When a user requests media, they're automatically routed to the nearest edge location. If the media isn't cached there, the CDN fetches it from S3 and caches it for future requests.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This way, instead of our Singaporean user waiting seconds to load an image originally stored on the US East Coast, they can load it from a server in the region closest to them.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We can configure the CDN to cache files based on their type and popularity. For example, we might cache images for 24 hours at edge locations since they rarely change once uploaded. This dramatically reduces latency for users and load on our origin S3 bucket. We can also use the CDN's built-in compression to reduce file sizes during transfer.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/be8e23ad6fe9f6a237d8a8b31909611c.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Global CDN Distribution</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-4">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">While this solves our global distribution problem, we're still serving the same files to all users. A user on a mobile device with a slow connection receives the same high-resolution image as someone on a fast desktop connection. We also have limited control over the caching strategy, which means popular media might get evicted from edge locations due to cache size limits, leading to unnecessary origin fetches.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-11r69q9"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-3ujfba" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Great Solution: CDN with Dynamic Media Optimization</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-5">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The most effective solution combines CDN distribution with dynamic media optimization. When media is uploaded, we use a media processing service (like Cloudinary or Imgix) to generate multiple variants optimized for different devices and network conditions. For images, this includes different resolutions and formats like WebP for supported browsers. For videos, we create multiple quality levels and use adaptive streaming (more details in the <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/youtube" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">YouTube</a> breakdown).</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">The CDN then serves these optimized variants based on the requesting device and network conditions. Mobile users automatically receive appropriately sized images, while desktop users get higher resolution versions. The client includes device information and network conditions in its requests, allowing the CDN to serve the most appropriate variant.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We also implement intelligent caching strategies. Popular media is cached more aggressively at edge locations, while less accessed content might have shorter TTLs. For viral content that suddenly gains popularity, we can proactively warm caches in regions where we predict high viewership.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/ef60fb23da021d600691e0d0876ddbdf.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">CDN with Dynamic Media Optimization</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-5">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This approach significantly improves user experience but introduces more complexity in our system. We need to manage multiple versions of each media file, increasing storage costs and complexity. The media processing pipeline adds latency to uploads and requires careful monitoring. Despite these challenges, this is the approach most large-scale media platforms use as it provides the best balance of performance and manageability.</div></div></div></div></div></div></div></div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="3-the-system-should-be-scalable-to-support-500m-dau">3) The system should be scalable to support 500M DAU</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">We've been keeping scale in mind throughout our deep dives, but let's summarize the key design choices that enable us to efficiently serve 500M daily active users while maintaining performance and reliability.</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Precomputed Feeds (Hybrid Approach): The cornerstone of our scalable feed generation is the hybrid approach. By precomputing feeds for the vast majority of users (those following accounts with fewer than our defined threshold of followers), we drastically reduce read-time load. The real-time merging for "celebrity" posts is a carefully considered trade-off to manage write amplification.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Content Delivery Network (CDN): Using a CDN like CloudFront for media delivery is essential for global scalability and low-latency access.  Dynamic media optimization further improves performance for diverse devices and network conditions.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Chunked Uploads: For large files (especially videos), chunking uploads improves reliability and user experience, and allows for parallel uploads.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Database Choice and Indexing: Our choice of DynamoDB (or a similarly scalable NoSQL database) provides horizontal scalability for metadata storage. The careful use of partition keys and sort keys ensured efficient queries.</div></li>
</ol><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Let's do some math and determine whether our existing scaling strategies are sufficient.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For the media files themselves, we can assume an average media size of ~2MB, so <span class="MuiBox-root mui-1vu004u">100M * 2MB = 200TB</span> of binary data each day.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">Starting with the media, this is about 750 PB of data over 10 years. S3 can handle this, but it's not cheap. If we worry about cost, we can always move the media that has not been accessed in a long time to cheaper storage like <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://aws.amazon.com/pm/s3-glacier" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Glacier</a>.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For the metadata, we're looking at <span class="MuiBox-root mui-1vu004u">100M * 1KB = 100GB</span> of new (non-binary) data created each day. Similarly, if we grow concerned about the price of DynamoDB, we can move infrequently accessed data over to S3.</div><div class="my-6"><div class="MuiBox-root mui-qzg9h6"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">This is a common pattern. The warmer the storage, the more expensive it is. Working back from CDN -&gt; Cache/Memory -&gt; SSD -&gt; HDD -&gt; Tape, we can always take data that is infrequently accessed and move it "down a level" to save money.</div></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">When it comes to throughput, as always, we can dynamically horizontally scale our microservices to handle the load. This happens automatically with most cloud providers and is triggered based on either CPU or memory usage thresholds. Each set of horizontally scaled microservices thus implicitly has a load balancer in front of it to distribute the traffic.</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">After all is said and done, you might have a design that looks something like this:</div><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><span class="w-full h-full"><object data="/_next/static/ef60fb23da021d600691e0d0876ddbdf.svg" type="image/svg+xml"></object></span></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Final Design</span></div></div></div></div><h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="what-is-expected-at-each-level"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/blog/the-system-design-interview-what-is-expected-at-each-level" target="_blank" rel="noopener noreferrer" linkcomponent="next/link" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">What is Expected at Each Level?</a></h2><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">So, what am I looking for at each level?</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="mid-level">Mid-level</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">At mid-level, I'm looking for a candidate's ability to create a working, high-level design that addresses the core requirements of Instagram. They should understand the basic components needed for photo/video upload, user follows, and feed generation. I expect them to propose a simple database schema and explain how posts would be stored and retrieved. While they might initially suggest a naive fan-out on read approach, with some hints they should be able to recognize its limitations and arrive at a fan-out on write solution. I want to see them problem-solve through performance bottlenecks when prompted. They should also grasp basic media storage concepts like using S3 and understand why a CDN might be necessary, even if they don't dive into the details of media optimization.</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="senior">Senior</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For senior candidates, I expect you to nail the majority of the deep dives, particularly around feed generation optimization and media delivery. You should understand the tradeoffs between fan-out on read, fan-out on write, and hybrid approaches, and be able to articulate why Instagram would choose a hybrid model to solve the "celebrity problem." I expect knowledge of efficient media upload handling for large files, and strong justifications for your technology choices. You should be able to discuss database indexing strategies in detail and understand how to optimize for our read-heavy workload. You likely would not have time to cover all the deep dives we did here, but if asked, you should be able to articulate the key tradeoffs and arrive at a reasonable solution.</div><h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="staff">Staff+</h3><div class="MuiTypography-root MuiTypography-body1 mui-1qj780c">For staff candidates, I'm evaluating your ability to identify the true scalability bottlenecks and propose elegant solutions that balance complexity against real needs. You should quickly recognize that feed generation and media delivery are the key challenges and focus your design accordingly. I expect you to discuss system evolution over time - how would we handle growing from 1M to 500M users? Rather than immediately jumping to complex distributed systems, you should be able to articulate where simpler solutions suffice and precisely when we'd need to evolve to more sophisticated approaches. Staff candidates demonstrate a keen understanding of operational concerns, anticipate failure modes, and propose robust solutions that prioritize user experience above all.</div></div></div>