<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-K System Design Interview Guide</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div><div class="flex flex-col gap-2 md:gap-4"><div class="flex flex-col"><h6 class="MuiTypography-root MuiTypography-h6 mui-zfm63x">Common Problems</h6><h1 class="MuiTypography-root MuiTypography-h2 mui-161snwm">Top-K Youtube Videos</h1></div><div class="flex flex-col md:flex-row gap-2 md:items-center justify-between"><div class="flex flex-col lg:flex-row gap-4 md:items-center"><a target="_blank" rel="noopener noreferrer" class="flex flex-row gap-2 items-center" href="https://www.linkedin.com/in/stefanmai/" style="text-decoration: none;"><img class="rounded-full" src="https://hellointerview-files.s3.us-west-2.amazonaws.com/public-media/stefan-headshot.png" alt="Stefan Mai" width="40" height="40"><div class="flex flex-col"><div class="flex flex-row gap-2 items-center"><p class="MuiTypography-root MuiTypography-body2 mui-ltrqv0">Stefan Mai</p><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeInherit mui-70s7oy" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LinkedInIcon"><path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77z"></path></svg></div><span class="MuiTypography-root MuiTypography-caption mui-1eozzb8">Ex-Meta &amp; Amazon Sr. Manager</span></div></a><div class="flex flex-row gap-4 md:gap-8 items-center"><div class="flex flex-row gap-1 items-center" aria-label="Difficulty"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-5 h-5 text-gray-500"><path stroke-linecap="round" stroke-linejoin="round" d="M15.362 5.214A8.252 8.252 0 0 1 12 21 8.25 8.25 0 0 1 6.038 7.047 8.287 8.287 0 0 0 9 9.601a8.983 8.983 0 0 1 3.361-6.867 8.21 8.21 0 0 0 3 2.48Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M12 18a3.75 3.75 0 0 0 .495-7.468 5.99 5.99 0 0 0-1.925 3.547 5.975 5.975 0 0 1-2.133-1.001A3.75 3.75 0 0 0 12 18Z"></path></svg><p class="MuiTypography-root MuiTypography-body2 mui-su24yt">medium</p></div><div class="flex flex-row gap-1 items-center" aria-label="Average time allowed in interview"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-5 h-5 text-gray-500"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg><p class="MuiTypography-root MuiTypography-body2 mui-1pb8xyp">35 min</p></div></div></div></div></div><hr class="MuiDivider-root MuiDivider-fullWidth mui-1rvhejo"></div>
<div class="mb-4"><iframe class="w-full aspect-video" src="https://www.youtube.com/embed/1lfktgZ9Eeo?si=wgqB2iThD-v638wO" title="System Design Interview: Design Top-K Youtube Videos w/ a Ex-Meta Senior Manager" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="understanding-the-problem">Understanding the Problem</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Let's assume we have a very large stream of views on YouTube (our stream is a firehose of VideoIDs). At any given moment we'd like to be able to query, <strong>precisely</strong>, the top K most viewed videos for a given time period (say 1 hour, 1 day, 1 month, all time) together with their counts.</div>
<div class="my-6"><div class="MuiBox-root mui-1ygn9bx"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The word precisely here has dramatic implications on this problem. It's a bit unrealistic for most applications, but an <em>approximate</em> solution leans heavily into probabilistic/approximate solutions which, for many roles, rely on esoteric knowledge of e.g. <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">count-min sketch</a>. Except in specialist situations, most reasonable interviewers are going to test general knowledge rather than something you'd learn on the job after reading some papers.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Our interviewer might give us some quantities to help us understand the scale of the system: Youtube Shorts had 70 billion views per day and approximately 1 hour of Youtube content is uploaded every second. Big!</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="functional-requirements"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#1-functional-requirements" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Functional Requirements</a></h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Core Requirements</strong></div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Clients should be able to query the top K videos (max 1000) for a given time period.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Time periods should be limited to 1 {hour, day, month} and all-time.</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Below the line (out of scope):</strong></div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Arbitrary time periods.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Arbitrary starting/ending points (we'll assume all queries are looking back from the current moment).</div></li>
</ul>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="non-functional-requirements"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#2-non-functional-requirements" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Non-Functional Requirements</a></h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Core Requirements</strong></div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We'll tolerate at most 1 min delay between when a view occurs and when it should be tabulated.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Our results must be precise, so we should not approximate. (Note: This would be unusual for most production systems)</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Our system should be able to handle a massive number (TBD - cover this later) of views per second.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We should support a massive number (TBD - cover this later) of videos.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We should return results within 10's of milliseconds.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Our system should be economical. We shouldn't need a 10k host fleet to solve this problem.</div></li>
</ol>
<div class="my-6"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Having quantities on your non-functional requirements will help you make decisions during your design. Note here that a system returning within 10's of milliseconds eliminates many candidates from the solution space - we'll need to favor precomputation.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">For quantities that are important to our design but that we can't estimate out of hand, we'll reserve some time to do so.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Here's how it might look on your whiteboard:</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/f7c2cf2b87f6c87f7285af6661a05cca" alt="Requirements"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Requirements</span></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="scale-estimation">Scale Estimation</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We've earmarked two quantities important to our design: (a) the number of views per second, and (b) the total number of videos. The first will help us understand the overall throughput of the system while the second is important for bounding the storage we'll need.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">First let's look at throughput:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>70B views/day / (100k seconds/day) = 700k tps</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Woo, that's a lot. We're definitely going to need to look for ways to shard this across many different hosts.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Now, let's talk storage. First we need the number of videos:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>Videos/Day = 1 hour content/second / (6 minutes content/video) * (100k seconds/day) = 1M videos/day
</span>Total Videos = 1M videos/day * 365 days/year * 10 years = 3.6B videos</code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">With that let's estimate how big a naive table of IDs and counts would be:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>Naive Storage = 4B videos * (8 bytes/ID + 8 bytes/count) = 64 GB</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Ok, probably something we can keep in memory if we're clever, especially if we use a number of hosts.</div>
<div class="my-6"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The goal of estimations isn't actually to see if you can do mental math (so don't be afraid of fudging the numbers). Your reflections on the implications of the quantities on your design, like which architectures are on or off the table as a result, is often the most important factor.</div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="the-set-up">The Set Up</h2>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="planning-the-approach">Planning the Approach</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Based on our requirements, we know we're going to make some observations for our interviewer:</div>
<div class="my-6"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Sharing your thought process is a great way to demonstrate seniority by showing you're thinking a step ahead.</div></div></div></div></div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">First, we need to index data from a very high volume stream. Most quantities will need to be precomputed in order to meet the latency requirements.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Next, problems like this typically have bottlenecks that are hidden behind bottlenecks: solving one problem creates (at least) one more. So we'll aim to solve the simplest problem first, and then add complexity as we go.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Finally, we'll note that the sliding time window adds more challenge. So we'll start with all-time and then try to figure out the rest.</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Our rough plan is thus:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Generate a basic (but not scalable solution) to the all-time top K problem.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Solve the primary issues of our basic solution.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Add a solution for the time period inputs.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Deep dive remaining bottlenecks until we run out of time.</div></li>
</ol>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="defining-the-core-entities"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#core-entities-2-minutes" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Defining the Core Entities</a></h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">In our problem, we have some basic entities we're going to work with to build our API:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Video</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">View</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Time Window</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">From a conceptual perspective this problem is straightforward so we're not going to spend any more time here. We might even skip this section to save time.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="api-or-system-interface"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#api-or-system-interface-5-minutes" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">API or System Interface</a></h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Our API guides the rest of the interview, but in this case it's really basic too! We simply need an API to retrieve the top K videos.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>GET /views/top?window={WINDOW}&amp;k={K}
</span>Response:
{
    "videos": [
        {
            "videoId": // ...
            "views": // ...
        }
    ]
}</code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We're not going to dawdle here and keep moving on to the meat of the interview.</div>
<div class="my-6"><div class="MuiBox-root mui-o9fqh4"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Especially for more senior candidates, it's important to focus your efforts on the "interesting" aspects of the interview. Spending too much time on obvious elements both deprives you of time for the more interesting parts of the interview but also signals to the interviewer that you may not be able to distinguish more complex pieces from trivial ones: a critical skill for senior engineers.</div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="high-level-design"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#high-level-design-10-15-minutes" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">High-Level Design</a></h2>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="1-a-basic-solution-for-all-time">1) A Basic Solution for All-Time</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Let's start with a simple solution for all-time top K videos which we'll build on a gigantic single host, then we can start to whittle away at optimization.</div>
<div class="my-6"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Especially for infrastructure-style interviews, I highly recommend reasoning about a solution first from the lense of a single host. Oftentimes the path to scale is straightforward from there. On the other hand if you solve scale first without thinking about how the actual mechanics of your solution work underneath, you're likely to back yourself into a corner.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We can do this by maintaining a table of video IDs and counts. This gets us an up-to-date count of every video, but iterating over all 4B keys to find the largest values is untenable, so we'll keep a heap of the top K videos which we can update with each increment. The vast majority of views will never touch this heap since they'll be below the threshold of the top 1000 (the max K we established in our functional requirements).</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/6d4992c16f1ee89f5f9e2fc360aca4d2" alt="Basic Solution"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Basic Solution</span></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The basic function is this: when a request comes in, we atomically increment the counter in the hash table with the incoming ID. We retrieve the updated count and test it against the floor of our heap. If the count is higher than our floor (i.e. the video belongs in the top 1,000) we update/insert it into the heap and heapify. Our clients query directly from that heap to retrieve the top K videos.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This is really simple and fast because we run it on a single host. And while this is possible conceptually, in memory, on a single host, we wouldn't want to do that. First, because the throughput we can support is likely more than an order of magnitude shy of the 700k TPS we need and secondly because that host becomes a single point of failure. What to do here?</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="2-primary-issues-of-the-basic-solution">2) Primary Issues of the Basic Solution</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We have two issues we need to address: how to maintain reliability in the presence of failures and how to scale the write throughput of the system. Let's talk about them in order.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">In order for our system to be reliable, we need to be able to gracefully handle node failures. In our single-node system we're going to be in the job search again if that host fails. No good.</div>
<div class="my-6 flex flex-col gap-4"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-ifi55z"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-1ev8i4f" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Bad Solution: Write out to a database</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">One option for us is to write our counts and heap out to a database. Because our database keeps all the state, our service is stateless and we can simple sub in a new host and pick up from there.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/ff3033007e4e576b0fff9243277aff65" alt="Database backed counters"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Database backed counters</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While attractive, this simply moves the problem to our database. We now need our counters to handle two round trip latencies to our database and the writes to the Counts need to be atomic. Furthermore, we introduce a data race in updating our heap or, worse, we're keeping a secondary index on all 4B videos which needs to be updated with every write.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-nhbct3"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-guv1gb" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Good Solution: Replication</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-1">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Another option for us is to maintain multiple replicas of our Counter instances. This not only allows us to scale out reads from our Client, but in the case of a failure we can simply remove those nodes from our load balancer. We'll enable retention on our stream so that, if we fail we can rebuild from scratch.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/66bfe6b55509625d6fb1ba066e7124fd" alt="Replicated counters"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Replicated counters</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-1">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While replicas improve our availability, they increase the load on our View stream and multiply the hardware we need to deploy. Further they still really don't handle total failures elegantly, we still need to bring up a new instance if one fails and having it "catch up" may take a very long time depending on how many views we can process per second. Ultimately we have to start at the beginning of the stream!</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-11r69q9"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-3ujfba" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Great Solution: Replicas with Snapshots</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-2">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">A great option for us is to maintain multiple replicas of our Counter instances and periodically snapshot our memory. This not only allows us to scale out reads from our Client, but we can also recover quickly in the case of a failure - we'll load the most recent snapshot and re-read from our stream until we "catch up". While we still need retention on the stream, we can now cap how long the stream is retained. Once we have snapshots of all our partitions, we can drop retention after that.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/509a1b929b62ff3087e18887fcd2204c" alt="Replicas with Snapshots"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Replicas with Snapshots</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-2">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While our snapshots significantly improve recovery time, we still need to be concerned about the processing throughput. If we need to process 700k views/second and our system can only do 1,400k views/second, we'll need 1 second to recover for every second that has passed since the last snapshot. Further these snapshots are going to be <em>big</em>, multi-GB images. The overhead of snapshotting may introduce additional load (dragging down our throughput) and we'll need a mechanism to make sure the snapshots are internally consistent.</div></div></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Ok, with some replicas and snapshots we're in a much more fault-tolerant state. Next, we need to scale the write throughput of our system as our replicas don't solve for the problem of having a massive firehose of incoming data. Your mind should immediately go to sharding/partitioning here.</div>
<div class="my-6 flex flex-col gap-4"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-ifi55z"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-1ev8i4f" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Bad Solution: Fixed partitioning by ID</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-3">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The most basic idea is for us to create P shards which each "own" a subset of the ID space. We can apply some modulo P to the incoming IDs so that we can route video views to the host who "owns" ID % P. This means each host+replica has a mutually exclusive, cumulatively exhaustive subset of all the videos.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This isn't complete (yet) because we now have P distinct top-K heaps, so our client needs to query every heap and merge them in order to return the global top-K. We add a service with the responsibility of querying each Counter shard (or its replica) and merging the result. We can use static DNS entries to refer to each shard and its replicas in a round-robin fashion: <span class="MuiBox-root mui-1vu004u">topk-shard-1</span>, <span class="MuiBox-root mui-1vu004u">topk-shard-2</span>, etc.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/7e8a1f0c43f966ed562c1724e8584bb7" alt="Fixed partitioning"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Fixed partitioning</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-3">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This approach has some tradeoffs. Because our partitions are fixed, our snapshots map perfectly to each shard. But this breaks if we need to increase P or the number of partitions which we would expect since new videos are being added to YouTube every day. Secondly, if P becomes large the Top-K service needs to make a large number of calls.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-nhbct3"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-guv1gb" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Good Solution: Elastic partitioning</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-4">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We can update our partitioning approach to allow for scaling. Like the Good solution we can create P shards of our Counter workers (+replica) which each own a subset of the ID space <em>using a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="http://highscalability.com/blog/2023/2/22/consistent-hashing-algorithm.html" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">consistent hash</a></em>. Instead of fixing the partitioning parameters, we can make them variable so we can scale up or down. When we need to add more capacity, new shards are spun up which read from two different snapshots (to the left and the right in our consistent hash ring) and filtered down to the ID space owned by this new shard.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/386dfcdc55aed72ec8d3c16726f5b9a4" alt="Elastic partitioning"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Elastic partitioning</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-4">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Since our partitions are no longer fixed, we need to have a registry like <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://zookeeper.apache.org/" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Zookeeper</a> so that each shards knows its assignment and the top-k service knows which shards to query for a given configuration. We'll need some orchestration for when we're increasing or decreasing the number of shards. And we still have the problem of if P becoming large requiring a large, scatter-gather operation.</div></div></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Ok cool, now we have a basic in-memory solution which is both fault-tolerant and (somewhat) scalable. But we haven't solved all our functional requirements yet. On to those pesky time windows.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="potential-deep-dives"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/delivery#deep-dives-10-minutes" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Potential Deep Dives</a></h2>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="1-handling-time-windows">1) Handling Time Windows</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While our "All-Time" solution conveniently can aggregate views forever, to handle time windows we need to age out views that happened outside that window. As an example, if a video got a single view at time T=0, if our time window is 1, by T=2 we need to make sure that video has a count of 0.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">One advantage we have is that the time windows we're working with are fixed and small: we only have 3. One disadvantage is they are very different granularities: from 1 minute to 1 month.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This is complicated so our best strategy is to start with something basic and probably bad then use it as inspiration to try come up with alternative solutions.</div>
<div class="my-6"><div class="MuiBox-root mui-o9fqh4"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Some candidates are so afraid of saying something wrong that they get stuck in a spot where they can't iterate to an optimal answer. The trick is communication! Let your interviewer know you understand the complexity and that you're going to start with something poor then iterate toward something good.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This avoids two common failure modes: (1) getting stuck trying to jump two steps, and (2) having your interviewer hop in to correct you prematurely because they think your initial bad idea is ... well ... bad.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Your interviewer is going to be looking for how you can think through this problem, not (necessarily) that you get the <em>optimal</em> answer. Identifying pinch points, solving them, and not getting stuck is critical. But if you can think of the best solution go for it!</div>
<div class="my-6 flex flex-col gap-4"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-ifi55z"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-1ev8i4f" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Bad Solution: Naive micro-buckets</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-5">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Instead of keeping all-time counts, we can keep counts for each video for every minute. When a request comes in, we truncate the non-minute components of the timestamp and add it to our count map at [videoId, minute]. Then, for each duration (1 minute, 1 hour, 1 day), we'll sum up all of the [videoId, minute] in that duration and add that to a separate top-K heap for that duration.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/7ac81fb35957154c89c3a0b31117ed65" alt="[BROKEN] Start"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">[BROKEN] Start</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-5">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This pretty clearly doesn't work. What's wrong?</div><ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">We have entries in the heap which could be stale (this video was in the top-K with 100 views last hour but has gotten none this hour).</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Summing over every [videoId, minute] for an entire month is expensive.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">The memory required balloons.</div></li>
</ol></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-nhbct3"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-guv1gb" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Good Solution: Heap expirations</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-6">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We can take the "bad" approach, and try to correct for its deficiencies.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">First, to address the heap staleness problem we can augment our heap with a "oldest increment" field. In it, we'll store the oldest timestamp in the aggregation that produced that total count for the window. Before querying, we'll need to walk our heap and check for "stale" entries which we'll refresh by summing over the constituent time windows. After our heap is "fresh" we can return our top k. (Note: that sometimes this refresh process may drop an entry out of the top-k which was previously in it, so we'll need to make our heap larger than the largest k, so maybe 2,000 rather than 1,000).</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Next, to deal with the aggregations, we can maintain multiple grains. In addition to 1 minute granularities, we might also maintain 1/2 of each of our durations (30 minutes, 12 hours, 15 days). We multiply our storage by (more than - because of sparsity of lower granularities) 3x in doing so, but significantly reduce the number of reads we need for any particular request. Now instead of trying to sum 1 month of minutes (43k) we can sum (1x(15 days) + 29*(12 hours) + 23*(30 minutes) + 29*(1 minute)) or 82 entries. Not too bad.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Lastly, we need a way to deal with the ballooning memory. We can definitely expire data older than 1 month since we no longer need it. But we might need the 1 minute data from 30 days ago to complete our window. Yuck.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/d524754a857052202264861a9c954e74" alt="Retention woes, note we need seconds throughout the whole window to complete the aggregate"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Retention woes, note we need seconds throughout the whole window to complete the aggregate</span></div></div></div></div><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-6">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This solution is complicated. We partly solved our heap staleness problem, but at read time we may be rebuilding much of its contents. We improved our aggregation performance by many orders of magnitude but we still need to maintain 1 minute granularities for a whole month. In the process we've built a system which can answer questions about counts of arbitrary time windows but we don't need that from our requirements!</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">As an interviewer: I'll give you partial credit for this. While this isn't a system I'd want to pull into production for this particular problem, you've shown your understanding of the deficiencies and demonstrated you have a toolbox for making fixes.</div></div></div></div></div></div></div><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 MuiAccordion-root MuiAccordion-rounded MuiAccordion-gutters mui-11r69q9"><div class="MuiButtonBase-root MuiAccordionSummary-root MuiAccordionSummary-gutters mui-3ujfba" tabindex="0" role="button" aria-expanded="false" aria-controls="panel1bh-content" id="panel1bh-header"><div class="MuiAccordionSummary-content MuiAccordionSummary-contentGutters mui-l0jafl"><p class="MuiTypography-root MuiTypography-body1 mui-h8owmt">Great Solution: Use two pointers</p></div><div class="MuiAccordionSummary-expandIconWrapper mui-awtdfi"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ExpandMoreIcon"><path d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg></div></div><div class="MuiCollapse-root MuiCollapse-vertical MuiCollapse-hidden mui-a0y2e3" style="min-height: 0px;"><div class="MuiCollapse-wrapper MuiCollapse-vertical mui-hboir5"><div class="MuiCollapse-wrapperInner MuiCollapse-vertical mui-8atqhb"><div aria-labelledby="panel1bh-header" id="panel1bh-content" role="region" class="MuiAccordion-region"><div class="MuiAccordionDetails-root mui-u7qq7e"><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="approach-7">Approach</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Since we're reading off a durable stream like Kafka, we can have pointers which pull messages at different offsets. We'll have 1 <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://en.wikipedia.org/wiki/Signal_edge" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">"rising edge"</a> which is when we <strong>add</strong> to the count and 3 "falling edges" where we decrement the count. For the falling edges we'll start reading from the stream with the appropriate offset (e.g. 1 hour, 1 month) and pause consuming when we get to an entry which is more recent than our current time minus that duration. This means we have a way to increment and decrement counts at just the right time.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">So, concretely, when a new view comes in the system adds this view to the current count for all active time windows, which means the view count for the last minute, last hour, and last month are all increased by one. After a certain amount of time, a view no longer falls within a time window and must be removed from the count—this is known as our "falling edge." Since our pointers for the "falling edge" are delayed by exactly the time window (like 1 hour old for the 1-hour window, 1 month old for the 1-month window), any views they process can be decremented from the respective counts.</div><div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/c6a4811dab843edeab4f4d61873a4c79" alt="Two pointers"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Two pointers</span></div></div></div></div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We'll need to maintain separate Counts for each time window (so we multiply our storage by 4x) as well as separate top-k heaps. But the Counts will never be stale.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">By keeping pointers into our stream that are lagged by the time window, we can decrement when those views fall outside the time windows.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Detailed Explanation</strong></div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Let's work an example. Assume that the following sequence of actions are going to take place:</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:05, a view of video A</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:20, a view of video B</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:40, a view of video B</div></li>
</ul><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Now we can walk through the state of the system at different time points to drive this home.</div><ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:00, all our heaps are empty and our counts are 0.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { }, Falling Edge at -1:00</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { }, Falling Edge at -24:00</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:05, we have a new view hit the top of the stream. This is a <em>rising edge</em> event for all our time periods. At this stage we increment the counts for every time window (1 hour, 1 day, 1 month, all time).
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { A: 1 }, Falling Edge at -0:55</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A: 1 }, Falling Edge at -23:55</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A: 1 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:20, we have another new view. Again, this is a <em>rising edge</em> event for all our time periods and we increment the counts for every time window.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { A: 1, B: 1 }, Falling Edge at -0:40</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A: 1, B: 1 }, Falling Edge at -23:40</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A: 1, B: 1 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 0:40, again a view on B.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { A: 1, B: 2 }, Falling Edge at -0:20</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A: 1, B: 2 }, Falling Edge at -23:20</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A: 1, B: 2 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 1:05, things get interesting. Our 1 hour falling edge pointer is now reading events that happened at 0:05 (a view on A). This means we are decrementing this count for the Hour counts, which is what we expect since that view has expired outside the window. Our 1 day counts are undisturbed.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { B: 2 }, Falling Edge at 0:05</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A:1, B: 2 }, Falling Edge at -22:55</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A:1, B: 2 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">At 1:20, the same thing happens for one of our B views. The falling edge has advanced to 0:20 where we're reading that a view happened and decrementing since this is the job of our falling edge pointer.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { B: 1 }, Falling Edge at 0:20</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A:1, B: 2 }, Falling Edge at -22:40</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A:1, B: 2 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">And at 1:40, the last B view expires for the hourly window.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { }, Falling Edge at 0:40</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { A:1, B: 2 }, Falling Edge at -22:20</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A:1, B: 2 }, No Falling Edge</div></li>
</ul>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Finally, for illustration, at 24:05, we expire the view that happened at 0:05 from the 1 day window.
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Hour Counter: Counts: { }, Falling Edge at 23:05</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">1 Day Counter: Counts: { B: 2 }, Falling Edge at 0:05</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">All Time Counter: Counts: { A:1, B: 2 }, No Falling Edge</div></li>
</ul>
</div></li>
</ul><h6 class="MuiTypography-root MuiTypography-body1 mui-1quhbks" id="challenges-7">Challenges</h6><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This puts a firm requirement on our stream processing that we need at least a 1 month (+ time since our last snapshot) retention. While we're probably storing at least a few days for disaster recovery, this significantly increases the costs of our Kafka deployment. We've also 4x'd our read load.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Because videos may fall out of the top 1,000, we need to make sure our heaps are storing significantly more than 1,000 (say, 2,000) so that we leave room for new entrants to the top as old impressions "expire".</div></div></div></div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="2-large-number-of-incoming-requests">2) Large number of incoming requests</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">So far we've been talking about how to handle a lot of views/writes, but what about reads? Given we have 1 minute between when a view happens and when it needs to be tabulated, the most natural solution is to add a cache. We can put a 1 minute TTL on the cache so results are never more stale than our requirement. When a request comes in, we can either serve it from cache or we query <em>all</em> Counters for the given heap of the request and then store the merged values back in the case.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/753132793e32145cef7beceea8b29981" alt="Full design with cache"></div></div></div><div class="MuiGrid-root MuiGrid-item mui-1wxaqej"><span class="MuiTypography-root MuiTypography-caption mui-17cupi8">Full design with cache</span></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="what-is-expected-at-each-level"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/blog/the-system-design-interview-what-is-expected-at-each-level" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">What is Expected at Each Level?</a></h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Ok, that was a lot. You may be thinking, “how much of that is actually required from me in an interview?” Let’s break it down.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="mid-level">Mid-level</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Breadth vs. Depth:</strong> A mid-level candidate will be mostly focused on breadth (80% vs 20%). You should be able to craft a high-level design that meets the functional requirements you've defined, but many of the components will be abstractions with which you only have surface-level familiarity.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Probing the Basics:</strong> Your interviewer will spend some time probing the basics to confirm that you know what each component in your system does. For example, if you add an API Gateway, expect that they may ask you what it does and how it works (at a high level). In short, the interviewer is not taking anything for granted with respect to your knowledge.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Mixture of Driving and Taking the Backseat:</strong> You should drive the early stages of the interview in particular, but the interviewer doesn’t expect that you are able to proactively recognize problems in your design with high precision. Because of this, it’s reasonable that they will take over and drive the later stages of the interview while probing your design.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>The Bar for Top K:</strong> For this question, an Mid-Level candidate will be able to come up with an end-to-end solution that probably isn't optimal. They'll have some insights into pinch points of the system and be able to solve some of them. They'll have familiarity with relevant technologies.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="senior">Senior</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Depth of Expertise</strong>: As a senior candidate, expectations shift towards more in-depth knowledge — about 60% breadth and 40% depth. This means you should be able to go into technical details in areas where you have hands-on experience. It's crucial that you demonstrate a deep understanding of key concepts and technologies relevant to the task at hand.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Advanced System Design</strong>: You should be familiar with advanced system design principles. For example, knowing about how to use consistent hashes to elastically scale partitioned data. You'd also be expected to understand how log-based event streaming (e.g. like implemented via Kafka or Redis Streams) functions.  Your ability to navigate these advanced topics with confidence and clarity is key.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Articulating Architectural Decisions</strong>: You should be able to clearly articulate the pros and cons of different architectural choices, especially how they impact scalability, performance, and maintainability. You justify your decisions and explain the trade-offs involved in your design choices.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Problem-Solving and Proactivity</strong>: You should demonstrate strong problem-solving skills and a proactive approach. This includes anticipating potential challenges in your designs and suggesting improvements. You need to be adept at identifying and addressing bottlenecks, optimizing performance, and ensuring system reliability.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>The Bar for Top K:</strong> For this question, a Senior candidate should be able to come up with an end-to-end solution that is near optimal. They'll identify most bottlenecks and proactively work to resolve them. They'll be familiar with relevant technologies and might even weigh the pros and cons of each.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="staff">Staff+</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Emphasis on Depth</strong>: As a staff+ candidate, the expectation is a deep dive into the nuances of system design — I'm looking for about 40% breadth and 60% depth in your understanding. This level is all about demonstrating that, while you may not have solved this particular problem before, you have solved enough problems in the real world to be able to confidently design a solution backed by your experience.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">You should know which technologies to use, not just in theory but in practice, and be able to draw from your past experiences to explain how they’d be applied to solve specific problems effectively. The interviewer knows you know the small stuff (caches, key-value stores, etc) so you can breeze through that at a high level so you have time to get into what is interesting.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>High Degree of Proactivity</strong>: At this level, an exceptional degree of proactivity is expected. You should be able to identify and solve issues independently, demonstrating a strong ability to recognize and address the core challenges in system design. This involves not just responding to problems as they arise but anticipating them and implementing preemptive solutions. Your interviewer should intervene only to focus, not to steer.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Practical Application of Technology</strong>: You should be well-versed in the practical application of various technologies. Your experience should guide the conversation, showing a clear understanding of how different tools and systems can be configured in real-world scenarios to meet specific requirements.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Complex Problem-Solving and Decision-Making</strong>: Your problem-solving skills should be top-notch. This means not only being able to tackle complex technical challenges but also making informed decisions that consider various factors such as scalability, performance, reliability, and maintenance.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Advanced System Design and Scalability</strong>: Your approach to system design should be advanced, focusing on scalability and reliability, especially under high load conditions. This includes a thorough understanding of distributed systems, load balancing, caching strategies, and other advanced concepts necessary for building robust, scalable systems.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>The Bar for Top K:</strong> For a staff+ candidate, expectations are high regarding depth and quality of solutions, particularly for the complex scenarios discussed earlier. A staff candidate will expand to cover deep dives that we haven't enumerated.</div>
</body>
</html>