<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka Deep Dive for System Design Interviews</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div><div class="flex flex-col gap-2 md:gap-4"><div class="flex flex-col"><h6 class="MuiTypography-root MuiTypography-h6 mui-zfm63x">Deep Dives</h6><h1 class="MuiTypography-root MuiTypography-h2 mui-161snwm">Kafka</h1><p class="MuiTypography-root MuiTypography-body2 mui-45a2r">Learn how to use Kafka in a wide variety of system design settings.</p></div></div><hr class="MuiDivider-root MuiDivider-fullWidth mui-1rvhejo"></div>
<div class="mb-4"><iframe class="w-full aspect-video" src="https://www.youtube.com/embed/DU8o-OTeoCc" title="Kafka Deep Dive w/ a Ex-Meta Staff Engineer" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="intro">Intro</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">There is a good chance you've heard of Kafka. It's popular. In fact, <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://kafka.apache.org/" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">according to their website</a>, it's used by 80% of the Fortune 100. If it's good enough to help scale the largest companies in the world, it's probably good enough for your next system design interview.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://notes.stephenholiday.com/Kafka.pdf" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Apache Kafka</a> is an open-source distributed event streaming platform that can be used either as a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/key-technologies#queue" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">message queue</a> or as a <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/in-a-hurry/key-technologies#streams--event-sourcing" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">stream processing system</a>. Kafka excels in delivering high performance, scalability, and durability. It’s engineered to handle vast volumes of data in real-time, ensuring that no message is ever lost and that each piece of data is processed as swiftly as possible.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">In this deep dive, we're going to take a top down approach. Starting with a zoomed out view of Kafka and progressing into more and more detail. If you know the basics, feel free to skip ahead to the more advanced sections.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="a-motivating-example">A Motivating Example</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">It's the World Cup (my personal favorite competition). And we run a website that provides real-time statistics on the matches. Each time a goal is scored, a player is booked, or a substitution is made, we want to update our website with the latest information.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Events are placed on a queue when they occur. We call the server or process responsible for putting these events on the queue the <strong>producer</strong>. Downstream, we have a server that reads events off the queue and updates the website. We call this the <strong>consumer</strong>.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/16854bb50ef88c4e0007485f3f6df620"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Now, imagine the World Cup expanded from just the top 48 teams to a hypothetical 1,000-team tournament, and all the games are now played at the same time. The number of events has increased significantly, and our single server hosting the queue is struggling to keep up. Similarly, our consumer feels like it has its mouth under a firehose and is crashing under the load.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We need to scale the system by adding more servers to distribute our queue. But how do we ensure that the events are still processed in order?</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/4e9f81e9828e27dee28601418214fe53"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">If we were to randomly distribute the events across the servers, we would have a mess on our hands. Goals would be scored before the match even started, and players would be booked for fouls they haven't committed yet.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">A logical solution is to distribute the items in the queue based on the game they are associated with. This way, all events for a single game are processed in order because they exist on the same queue. This is one of the fundamental ideas behind Kafka: <strong>messages sent and received through Kafka require a user specified distribution strategy.</strong></div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/e47e5c18930db9ed69bbccf4691539a2"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">But what about our consumer, it's still overwhelmed. It is easy enough to add more, but how do we make sure that each event is only processed once? We can group consumers together into what Kafka calls a <strong>consumer group</strong>. With consumer groups, each event is guaranteed to only be processed by one consumer in the group.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/ee062dd7fc1dc9c11e1149ced57a570c"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Lastly, we've decided that we want to expand our hypothetical World Cup to more sports, like basketball. But we don't want our soccer website to cover basketball events, and we don't want our basketball website to cover soccer events. So we introduce the concept of <strong>topics</strong>. Each event is associated with a topic, and consumers can subscribe to specific topics. Therefore, our consumers who update the soccer website only subscribe to the soccer topic, and our consumers that update the basketball website only subscribe to basketball events.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/c4b336a4861244c1657ee0a36b465730"></div></div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="basic-terminology-and-architecture">Basic Terminology and Architecture</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The example is great, but let's define Kafka a bit more concretely by formalizing some of the key terms and concepts introduced above.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">A Kafka cluster is made up of multiple <strong>brokers</strong>. These are just individual servers (they can be physical or virtual). Each broker is responsible for storing data and serving clients. The more brokers you have, the more data you can store and the more clients you can serve.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Each broker has a number of <strong>partitions</strong>. Each partition is an ordered, immutable sequence of messages that is continually appended to -- think of like a log file. Partitions are the way Kafka scales as they allow for messages to be consumed in parallel.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">A <strong>topic</strong> is just a logical grouping of partitions. Topics are the way you publish and subscribe to data in Kafka. When you publish a message, you publish it to a topic, and when you consume a message, you consume it from a topic. Topics are always multi-producer; that is, a topic can have zero, one, or many producers that write data to it.</div>
<div class="my-4"><div class="MuiBox-root mui-1ygn9bx"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">So what is the difference between a topic and a partition?</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">A topic is a logical grouping of messages. A partition is a physical grouping of messages. A topic can have multiple partitions, and each partition can be on a different broker. Topics are just a way to organize your data, while partitions are a way to scale your data.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Last up we have our <strong>producers</strong> and <strong>consumers</strong>. Producers are the ones who write data to topics, and consumers are the ones who read data from topics. While Kafka exposes a simple API for both producers and consumers, the creation and processing of messages is on you, the developer. Kafka doesn't care what the data is, it just stores and serves it.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Importantly, you can use Kafka as either a message queue or a stream. Frankly, the distinction here is minor. The only meaningful difference is with how consumers interact with the data. In a message queue, consumers read messages from the queue and then acknowledge that they have processed the message. In a stream, consumers read messages from the stream and then process them, but they don't acknowledge that they have processed the message. This allows for more complex processing of the data.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="how-kafka-works">How Kafka Works</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">When an event occurs, the producer formats a message, also referred to as a record, and sends it to a Kafka topic. A message consists of one required field, the value, and three optional fields: a key, a timestamp, and headers. The key is used to determine which partition the message is sent to, and the timestamp is used to order messages within a partition. Headers, like HTTP headers, are key-value pairs that can be used to store metadata about the message.</div>
<div class="flex flex-row w-full justify-center"><div class="my-4 flex-col w-full max-w-[200px]"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/ea72a3302bc0beca8e45c13c70b04b10"></div></div></div></div></div></div></div>
<div class="my-4"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While not strictly required, the key is used to determine which partition the message is sent to. If you don't provide a key, Kafka will randomly assign the message to a partition. So when designing a large, distributed system like you're likely to be asked about in your interview, you'll want to use keys to ensure that messages are processed in order, and the choice of that key is important. More on this later.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">As a quick example, here is how we might put a message on the topic <span class="MuiBox-root mui-1vu004u">my-topic</span> using the Kafka command line tool <span class="MuiBox-root mui-1vu004u">kafka-console-producer</span>:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>kafka-console-producer --broker-list localhost:9092 --topic my_topic --property </span><span class="token" style="color: rgb(80, 161, 79);">"parse.key=true"</span><span> --property </span><span class="token" style="color: rgb(80, 161, 79);">"key.separator=:"</span><span>
</span><span></span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> key1: Hello, Kafka with key</span><span class="token" style="color: rgb(64, 120, 242);">!</span><span>
</span><span></span><span class="token" style="color: rgb(64, 120, 242);">&gt;</span><span> key2: Another message with a different key</span></code></div></div></pre>
<div class="my-4"><div class="MuiBox-root mui-1ygn9bx"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The <span class="MuiBox-root mui-1vu004u">--property "parse.key=true"</span> and <span class="MuiBox-root mui-1vu004u">--property "key.separator=:"</span> flags are used to specify that the key-value pairs are separated by a colon.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">We can see what the same would look like using <span class="MuiBox-root mui-1vu004u">kafkajs</span>, a popular Node.js client for Kafka:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Initialize the Kafka client</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> kafka </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">new</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">Kafka</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">clientId</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'my-app'</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">brokers</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span class="token" style="color: rgb(80, 161, 79);">'localhost:9092'</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Initialize the producer</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> producer </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> kafka</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">producer</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> </span><span class="token function-variable" style="color: rgb(64, 120, 242);">run</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">async</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token arrow" style="color: rgb(64, 120, 242);">=&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Connecting the producer</span><span>
</span><span>  </span><span class="token control-flow" style="color: rgb(166, 38, 164);">await</span><span> producer</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">connect</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span>  </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Sending messages to the topic 'my_topic' with keys</span><span>
</span><span>  </span><span class="token control-flow" style="color: rgb(166, 38, 164);">await</span><span> producer</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">send</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">topic</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'my_topic'</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">messages</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span>
</span><span>      </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">key</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'key1'</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">value</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'Hello, Kafka with key!'</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>      </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">key</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'key2'</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">value</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'Another message with a different key'</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">]</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">When a message is published to a Kafka topic, Kafka first determines the appropriate partition for the message. This partition selection is critical because it influences the distribution of data across the cluster. This is a two-step process:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Partition Determination</strong>: Kafka uses a partitioning algorithm that hashes the message key to assign the message to a specific partition. If the message does not have a key, Kafka can either round-robin the message to partitions or follow another partitioning logic defined in the producer configuration. This ensures that messages with the same key always go to the same partition, preserving order at the partition level.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Broker Assignment</strong>: Once the partition is determined, Kafka then identifies which broker holds that particular partition. The mapping of partitions to specific brokers is managed by the Kafka cluster metadata, which is maintained by the Kafka controller (a role within the broker cluster). The producer uses this metadata to send the message directly to the broker that hosts the target partition.</div>
</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Each partition in Kafka functions essentially as an append-only log file. Messages are sequentially added to the end of this log, which is why Kafka is commonly described as a distributed commit log. This append-only design is central to Kafka’s architecture, providing several important benefits:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Immutability</strong>: Once written, messages in a partition cannot be altered or deleted. This immutability is crucial for Kafka’s performance and reliability. It simplifies replication, speeds up recovery processes, and avoids consistency issues common in systems where data can be changed.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Efficiency</strong>: By restricting operations to appending data at the end of the log, Kafka minimizes disk seek times, which are a major bottleneck in many storage systems.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Scalability</strong>: The simplicity of the append-only log mechanism facilitates horizontal scaling. More partitions can be added and distributed across a cluster of brokers to handle increasing loads, and each partition can be replicated across multiple brokers to enhance fault tolerance.</div>
</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Each message in a Kafka partition is assigned a unique offset, which is a sequential identifier indicating the message’s position in the partition. This offset is used by consumers to track their progress in reading messages from the topic. As consumers read messages, they maintain their current offset and periodically commit this offset back to Kafka. This way, they can resume reading from where they left off in case of failure or restart.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/7fbdfddbbabaa69e3cccbeb9aa020cc9"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Once a message is published to the designated partition, Kafka ensures its durability and availability through a robust replication mechanism. Kafka employs a leader-follower model for replication, which works as follows:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Leader Replica Assignment</strong>: Each partition has a designated leader replica, which resides on a broker. This leader replica is responsible for handling all read and write requests for the partition. The assignment of the leader replica is managed centrally by the cluster controller, which ensures that each partition’s leader replica is effectively distributed across the cluster to balance the load.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Follower Replication</strong>: Alongside the leader replica, several follower replicas exist for each partition, residing on different brokers. These followers do not handle direct client requests; instead, they passively replicate the data from the leader replica. By replicating the messages received by the leader replica, these followers act as backups, ready to take over should the leader replica fail.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Synchronization and Consistency</strong>: Followers continuously sync with the leader replica to ensure they have the latest set of messages appended to the partition log. This synchronization is crucial for maintaining consistency across the cluster. If the leader replica fails, one of the follower replicas that has been fully synced can be quickly promoted to be the new leader, minimizing downtime and data loss.</div>
</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>Controller's Role in Replication</strong>: The controller within the Kafka cluster manages this replication process. It monitors the health of all brokers and manages the leadership and replication dynamics. When a broker fails, the controller reassigns the leader role to one of the in-sync follower replicas to ensure continued availability of the partition.</div>
</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Last up, consumers read messages from Kafka topics. They can read messages in two ways: either by subscribing to a topic and receiving messages as they arrive (this is called a <strong>push model</strong>), or by polling Kafka for new messages at regular intervals (this is called a <strong>pull model</strong>).</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">To round out our earlier example, here is how we might consume messages from the <span class="MuiBox-root mui-1vu004u">my-topic</span> topic using the Kafka command line tool <span class="MuiBox-root mui-1vu004u">kafka-console-consumer</span>:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span>kafka-console-consumer --bootstrap-server localhost:9092 --topic my_topic --from-beginning
</span>
<span></span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;"># Output</span><span>
</span><span>key1: Hello, Kafka with key</span><span class="token" style="color: rgb(64, 120, 242);">!</span><span>
</span>key2: Another message with a different key</code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Similarly, with <span class="MuiBox-root mui-1vu004u">kafkajs</span>, we can consume messages from the <span class="MuiBox-root mui-1vu004u">my_topic</span> topic:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Initialize the Kafka client</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> kafka </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">new</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">Kafka</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">clientId</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'my-app'</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">brokers</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">[</span><span class="token" style="color: rgb(80, 161, 79);">'localhost:9092'</span><span class="token" style="color: rgb(56, 58, 66);">]</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Initialize the consumer</span><span>
</span><span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> consumer </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> kafka</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">consumer</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">groupId</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'my-group'</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span></span><span class="token" style="color: rgb(166, 38, 164);">const</span><span> </span><span class="token function-variable" style="color: rgb(64, 120, 242);">run</span><span> </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">async</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token arrow" style="color: rgb(64, 120, 242);">=&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Connecting the consumer</span><span>
</span><span>  </span><span class="token control-flow" style="color: rgb(166, 38, 164);">await</span><span> consumer</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">connect</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span>  </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Subscribing to the topic 'my_topic'</span><span>
</span><span>  </span><span class="token control-flow" style="color: rgb(166, 38, 164);">await</span><span> consumer</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">subscribe</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span> </span><span class="token literal-property" style="color: rgb(228, 86, 73);">topic</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(80, 161, 79);">'my_topic'</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span>
<span>  </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Consuming messages</span><span>
</span><span>  </span><span class="token control-flow" style="color: rgb(166, 38, 164);">await</span><span> consumer</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">run</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token function-variable" style="color: rgb(64, 120, 242);">eachMessage</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(166, 38, 164);">async</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token parameter" style="color: rgb(56, 58, 66);">{</span><span class="token parameter"> topic</span><span class="token parameter" style="color: rgb(56, 58, 66);">,</span><span class="token parameter"> partition</span><span class="token parameter" style="color: rgb(56, 58, 66);">,</span><span class="token parameter"> message </span><span class="token parameter" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span> </span><span class="token arrow" style="color: rgb(64, 120, 242);">=&gt;</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>      </span><span class="token console" style="color: rgb(183, 107, 1);">console</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">log</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>        </span><span class="token literal-property" style="color: rgb(228, 86, 73);">value</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> message</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token property-access">value</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">toString</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>        </span><span class="token literal-property" style="color: rgb(228, 86, 73);">key</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> message</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token property-access">key</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">toString</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span>      </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span>    </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Tying it all together, we get something like this:</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/ad17548cbc6fe72490ecd9a489a42aa3"></div></div></div></div></div></div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="when-to-use-kafka-in-your-interview">When to use Kafka in your interview</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Kafka can be used as either a message queue or a stream.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The key difference between the two lies in how consumers interact with the data. In a message queue, consumers typically pull messages from the queue when they are ready to process them. In a stream, consumers continuously consume and process messages as they arrive in real-time, similar to drinking from a flowing river.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Consider adding a message queue to your system when:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You have processing that can be done asynchronously. YouTube is a good example of this. When users upload a video we can make the standard definition video available immediately and then put the video (via link) a Kafka topic to be transcoded when the system has time.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You need to ensure that messages are processed in order. We could use Kafka for our virtual waiting queue in <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/ticketmaster" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Design Ticketmaster</a> which is meant to ensure that users are let into the booking page in the order they arrived.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You want to decouple the producer and consumer so that they can scale independently. Usually this means that the producer is producing messages faster than the consumer can consume them. This is a common pattern in microservices where you want to ensure that one service can't take down another.</div></li>
</ul>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Streams are useful when:</div>
<ul class="MuiList-root MuiList-padding mui-sedpvs">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">You require continuous and immediate processing of incoming data, treating it as a real-time flow. See <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/ad-click-aggregator" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Design an Ad Click Aggregator</a> for an example where we aggregate click data in real-time.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0">Messages need to be processed by multiple consumers simultaneously. In <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/fb-live-comments" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Design FB Live Comments</a> we can use Kafka as a pub/sub system to send comments to multiple consumers.</div></li>
</ul>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="what-you-should-know-about-kafka-for-system-design-interviews">What you should know about Kafka for System Design Interviews</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">There is a lot to know about Kafka. But we'll focus in on this bits that are most likely to be relevant to your system design interview.</div>
<div class="my-4"><div class="MuiBox-root mui-1ygn9bx"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This deep dive is rather exhaustive, especially as it pertains to the knowledge needed for an interview. Don't feel overwhelmed. If you're a junior or mid-level engineer, you likely won't need to know anything below this point. If you're a senior engineer, you should be familiar with some of the topics we're about to cover. Staff engineers and above would do well to know the majority of the topics below, but by no means is this knowledge required to pass an interview.</div></div></div></div></div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="scalability">Scalability</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Let's start by understanding the constraints of a single Kafka broker. It's important in your interview to estimate the throughput and number of messages you'll be storing in order to determine whether we need to worry about scaling in the first place.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">First, there is no hard limit on the size of a Kafka message as this can be configured via <span class="MuiBox-root mui-1vu004u">message.max.bytes</span>. However, it is recommended to keep messages under 1MB to ensure optimal performance via reduced memory pressure and better network utilization.</div>
<div class="my-4"><div class="MuiBox-root mui-o9fqh4"><div class="MuiBox-root mui-3t6lyr"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">It's a common anti-pattern in system design interviews to store large blobs of data in Kafka. Kafka is not a database, and it's not meant to store large files. It's meant to store small messages that can be processed quickly.</div><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">For example, when designing YouTube, we need to perform post-processing on videos after uploading to chunk and transcode them. Naively, you might place the videos in Kafka so that the chunk/transcoding worker can pull them off the queue asynchronously and process them. This is not a good idea. Instead, you should store the videos in a distributed file system like S3 and place a message in Kafka with the location of the video in S3. This way, the Kafka message is small and serves as a pointer to the full video in S3.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">On good hardware, a single broker can store around 1TB of data and handle as many as 1M messages per second (this is very hand wavy as it depends on message size and hardware specs, but is a useful estimate). If your design does not require more than this, than scaling is likely not a relevant conversation.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">In the case that you do need to scale, you have a couple strategies at your disposal:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Horizontal Scaling With More Brokers</strong>: The simplest way to scale Kafka is by adding more brokers to the cluster. This helps distribute the load and offers greater fault tolerance. Each broker can handle a portion of the traffic, increasing the overall capacity of the system. It's really important that when adding brokers you ensure that your topics have sufficient partitions to take advantage of the additional brokers. More partitions allow more parallelism and better load distribution. If you are under partitioned, you won't be able to take advantage of these newly added brokers.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Partitioning Strategy</strong>: This should be the main focus of your scaling strategy in an interview and is the main decision you make when dealing with Kafka clusters (since much of the scaling happens dynamically in managed services nowadays). You need to decide how to partition your data across the brokers. This is done by choosing a key for your messages since the partition is determined by a consistent hashing algorithm on the key. If you choose a bad key, you can end up with hot partitions that are overwhelmed with traffic. Good keys are ones that are evenly distributed across the partition space.</div></li>
</ol>
<div class="my-4"><div class="MuiBox-root mui-1ygn9bx"><div class="MuiBox-root mui-14185gn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">It's worth noting that outside of an interview, many scaling consideration are made easy via managed Kafka services like Confluent Cloud or AWS MSK. These services handle much of the scaling for you, but you should still understand the underlying concepts.</div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">When working with Kafka, you're usually thinking about scaling topics rather than the entire cluster. This is because different topics can have different requirements. For example, you may have a topic that is very high throughput and needs to be partitioned across many brokers, while another topic is low throughput and can be handled by a single broker. To scale a topic, you can increase the number of partitions, which will allow you to take advantage of more brokers.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>How can we handle hot partitions?</strong></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Interviewers love to ask this question. Consider an <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/ad-click-aggregator" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Ad Click Aggregator</a> where Kafka stores a stream of click events from when users click on ads. Naturally, you would start by partitioning by ad id. But when Nike launches their new Lebron James ad, you better believe that partition is going to be overwhelmed with traffic and you'll have a hot partition on your hands.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">There are a few strategies to handle hot partitions:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Random partitioning with no key</strong>: If you don't provide a key, Kafka will randomly assign a partition to the message, guaranteeing even distribution. The downside is that you lose the ability to guarantee order of messages. If this is not important to your design, then this is a good option.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Random salting</strong>: We can add a random number or timestamp to the ad ID when generating the partition key. This can help in distributing the load more evenly across multiple partitions, though it may complicate aggregation logic later on the consumer side. This is often referred to as "salting" the key.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Use a compound key</strong>: Instead of using just the ad ID, use a combination of ad ID and another attribute, such as geographical region or user ID segments, to form a compound key. This approach helps in distributing traffic more evenly and is particularly useful if you can identify attributes that vary independently of the ad ID.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Back pressure</strong>: Depending on your requirements, one easy solution is to just slow down the producer. If you're using a managed Kafka service, they may have built-in mechanisms to handle this. If you're running your own Kafka cluster, you can implement back pressure by having the producer check the lag on the partition and slow down if it's too high.</div></li>
</ol>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="fault-tolerance-and-durability">Fault Tolerance and Durability</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">If you chose Kafka, one reason may have been because of its strong durability guarantees. But how does Kafka ensure that your data is safe and that no messages are lost?</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Kafka ensures data durability through its replication mechanism. Each partition is replicated across multiple brokers, with one broker acting as the leader and others as followers. When a producer sends a message, it is written to the leader and then replicated to the followers. This ensures that even if a broker fails, the data remains available. Producer acknowledgments (<span class="MuiBox-root mui-1vu004u">acks</span> setting) play a crucial role here. Setting <span class="MuiBox-root mui-1vu004u">acks=all</span> ensures that the message is acknowledged only when all replicas have received it, guaranteeing maximum durability.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Depending on how much durability you need, you can configure the replication factor of your topics. The replication factor is the number of replicas that are maintained for each partition. A replication factor of 3 is common, meaning that each partition has 2 replicas. So if one broker fails, the data is still available on the other two and we can promote a follower to be the new leader.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag"><strong>But what happens when a consumer goes down?</strong></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Kafka is usually thought of as always available. You'll often hear people say, "Kafka is always available, sometimes consistent." This means that a question like, "what happens if Kafka goes down?" is not very realistic, and you may even want to gently push back on the interviewer if they ask this.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">What is far more relevant and likely is that a consumer goes down. When a consumer fails, Kafka's fault tolerance mechanisms help ensure continuity:</div>
<ol style="list-style: outside decimal;">
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Offset Management</strong>: Remember that partitions are just append-only logs where each message is assigned a unique offset. Consumers commit their offsets to Kafka after they process a message. This is the consumers way of saying, "I've processed this message." When a consumer restarts, it reads its last committed offset from Kafka and resumes processing from there, ensuring no messages are missed or duplicated.</div></li>
<li class="MuiListItem-root MuiListItem-gutters MuiListItem-padding mui-ioa8ei"><div class="MuiBox-root mui-0"><strong>Rebalancing</strong>: When part of a consumer group, if one consumer goes down, Kafka will redistribute the partitions among the remaining consumers so that all partitions are still being processed.</div></li>
</ol>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">The trade-off you may need to consider in an interview is when to commit offsets. In <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/web-crawler" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Design a Web Crawler</a>, for example, you want to be careful not to commit the offset until you're sure the raw HTML has been stored in your blob storage. The more work a consumer has to do, the more likely you are to have to redo work if the consumer fails. For this reason, keeping the work of the consumer as small as possible is a good strategy -- as was the case in Web Crawler where we broke the crawler into 2 phases: downloading the HTML and then parsing it.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="handling-retries-and-errors">Handling Retries and Errors</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">While Kafka itself handles most of the reliability (as we saw above), our system may fail getting messages into and out of Kafka. We need to handle these scenarios gracefully.</div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="producer-retries">Producer Retries</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">First up, we may fail to get a message to Kafka in the first place. Errors can occur due to network issues, broker unavailability, or transient failures. To handle these scenarios gracefully, Kafka producers support automatic retries. Here’s a sneak peek of how you can configure them:</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">const</span><span> producer </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> kafka</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">producer</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">retry</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">retries</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">5</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Retry up to 5 times</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">initialRetryTime</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">100</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Wait 100ms between retries</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">idempotent</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">true</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre>
<div class="my-4"><div class="MuiBox-root mui-1147lff"><div class="MuiBox-root mui-zvu67g"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-6 h-6 heroicon-sw-2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"></path></svg></div><div class="MuiBox-root mui-79elbk"><div style="overflow: hidden; max-height: 300px;"><div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">You'll want to ensure that you enable idempotent producer mode to avoid duplicate messages when retries are enabled. This just ensures that messages are only sent once in the case we incorrectly think they weren't sent.</div></div></div></div></div>
<h4 class="MuiTypography-root MuiTypography-h5 mui-1jefea8" id="consumer-retries">Consumer Retries</h4>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">On the consumer side, we may fail to process a message for any number of reasons. Kafka does not actually support retries for consumers out of the box (but <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://aws.amazon.com/sqs/" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">AWS SQS</a> does!) so we need to implement our own retry logic. One common pattern is to set up a custom topic that we can move failed messages to and then have a separate consumer that processes these messages. This way, we can retry messages as many times as we want without affecting the main consumer. If a given message is retried too many times, we can move it to a dead letter queue (DLQ). DLQs are just a place to store failed messages so that we can investigate them later.</div>
<div class="my-4 flex-col w-full undefined"><div class="MuiBox-root mui-10khgmf" style="cursor: pointer;"><div class="MuiGrid-root MuiGrid-container MuiGrid-direction-xs-column mui-1tdxmx0"><div class="MuiGrid-root MuiGrid-item mui-tolxbf"><div class="relative w-full"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeSmall mui-wksd04" tabindex="0" type="button" aria-label="zoom-in"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium mui-10dohqv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ZoomInIcon"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"></path><path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"></path></svg><span class="MuiTouchRipple-root mui-w0pj6f"></span></button><div class="w-full"><img class="w-full max-w-full max-h-full" src="https://d248djf5mc6iku.cloudfront.net/excalidraw/5b0431c9552adb9e764f474c3e19b248"></div></div></div></div></div></div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">You'll see in our <a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover mui-pvpazu" href="https://www.hellointerview.com/learn/system-design/problem-breakdowns/web-crawler" target="_blank" rel="noopener noreferrer" style="color: rgb(99, 115, 129); cursor: pointer; font-weight: 600; text-decoration: underline;">Web Crawler</a> breakdown that we actually opt for SQS instead of Kafka so that we could take advantage of the built-in retry and dead letter queue functionality without having to implement it ourselves.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="performance-optimizations">Performance Optimizations</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Especially when using Kafka as an event stream, we need to be mindful of performance so that we can process messages as quickly as possible.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">This first thing we can do is batch messages in the producer before sending them to Kafka. Again, this is just a simple configuration.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">const</span><span> producer </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> kafka</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">producer</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">batch</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">maxSize</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">16384</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span> </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Maximum batch size in bytes</span><span>
</span><span>    </span><span class="token literal-property" style="color: rgb(228, 86, 73);">maxTime</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token" style="color: rgb(183, 107, 1);">100</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>   </span><span class="token" style="color: rgb(160, 161, 167); font-style: italic;">// Maximum time to wait before sending a batch</span><span>
</span><span>  </span><span class="token" style="color: rgb(56, 58, 66);">}</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Another common way to improve throughput is by compressing the messages on the producer. This can be done by setting the <span class="MuiBox-root mui-1vu004u">compression</span> option in the producer configuration. Kafka supports several compression algorithms, including GZIP, Snappy, and LZ4. Essentially, we're just making the messages smaller so that they can be sent faster.</div>
<pre><div class="MuiBox-root mui-xnilmx"><div class="MuiBox-root mui-v2ritd"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="w-4 h-4  cursor-pointer" aria-label="Copy"><path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"></path></svg></div><div style="background: rgb(250, 250, 250); color: rgb(56, 58, 66); font-family: &quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 2; hyphens: none; padding: 1em; margin: 0px; overflow: auto; border-radius: 0.375rem; border: none;"><code font-size="18" style="white-space: pre;"><span class="token" style="color: rgb(166, 38, 164);">const</span><span> producer </span><span class="token" style="color: rgb(64, 120, 242);">=</span><span> kafka</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token method property-access" style="color: rgb(64, 120, 242);">producer</span><span class="token" style="color: rgb(56, 58, 66);">(</span><span class="token" style="color: rgb(56, 58, 66);">{</span><span>
</span><span>  </span><span class="token literal-property" style="color: rgb(228, 86, 73);">compression</span><span class="token" style="color: rgb(64, 120, 242);">:</span><span> </span><span class="token maybe-class-name">CompressionTypes</span><span class="token" style="color: rgb(56, 58, 66);">.</span><span class="token" style="color: rgb(183, 107, 1);">GZIP</span><span class="token" style="color: rgb(56, 58, 66);">,</span><span>
</span><span></span><span class="token" style="color: rgb(56, 58, 66);">}</span><span class="token" style="color: rgb(56, 58, 66);">)</span><span class="token" style="color: rgb(56, 58, 66);">;</span></code></div></div></pre>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Arguably the biggest impact you can have to performance comes back to your choice of partition key. The goal is to maximize parallelism by ensuring that messages are evenly distributed across partitions. In your interview, discussing the partition strategy, as we go into above, should just about always be where you start.</div>
<h3 class="MuiTypography-root MuiTypography-h4 mui-hkpafq" id="retention-policies">Retention Policies</h3>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Kafka topics have a retention policy that determines how long messages are retained in the log. This is configured via the <span class="MuiBox-root mui-1vu004u">retention.ms</span> and <span class="MuiBox-root mui-1vu004u">retention.bytes</span> settings. The default retention policy is to keep messages for 7 days or until the log reaches 1GB, whichever comes first.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">In your interview, you may be asked to design a system that needs to store messages for a longer period of time. In this case, you can configure the retention policy to keep messages for a longer duration. Just be mindful of the impact on storage costs and performance.</div>
<h2 class="MuiTypography-root MuiTypography-h3 mui-1rzqq5q" id="summary">Summary</h2>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Congrats! You made it through. Let's recap quickly.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">Apache Kafka is an open-source, distributed event streaming platform engineered for high performance, scalability, and durability. It uses producers to send messages to topics, and consumers to read them, with messages being stored in ordered, immutable partitions across multiple brokers (servers). It is highly suited for real-time data processing and asynchronous message queuing in system design.</div>
<div class="MuiTypography-root MuiTypography-body1 mui-1p1f0ag">When it comes to scale, make sure you start by discussing your partitioning strategy and how you'll handle hot partitions. And remember, Kafka is always available, sometimes consistent 😝</div>
</body>
</html>